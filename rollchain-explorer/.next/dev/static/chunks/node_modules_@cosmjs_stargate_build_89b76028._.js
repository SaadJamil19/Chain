(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@cosmjs/stargate/build/accounts.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.accountFromAny = void 0;
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const auth_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js [client] (ecmascript)");
const vesting_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js [client] (ecmascript)");
function uint64FromProto(input) {
    return math_1.Uint64.fromString(input.toString());
}
function accountFromBaseAccount(input) {
    const { address, pubKey, accountNumber, sequence } = input;
    const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
    return {
        address: address,
        pubkey: pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
    };
}
/**
 * Basic implementation of AccountParser. This is supposed to support the most relevant
 * common Cosmos SDK account types. If you need support for exotic account types,
 * you'll need to write your own account decoder.
 */ function accountFromAny(input) {
    const { typeUrl, value } = input;
    switch(typeUrl){
        // auth
        case "/cosmos.auth.v1beta1.BaseAccount":
            return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount":
            {
                const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        // vesting
        case "/cosmos.vesting.v1beta1.BaseVestingAccount":
            {
                const baseAccount = vesting_1.BaseVestingAccount.decode(value)?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount":
            {
                const baseAccount = vesting_1.ContinuousVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount":
            {
                const baseAccount = vesting_1.DelayedVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount":
            {
                const baseAccount = vesting_1.PeriodicVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
                (0, utils_1.assert)(baseAccount);
                return accountFromBaseAccount(baseAccount);
            }
        default:
            throw new Error(`Unsupported type: '${typeUrl}'`);
    }
}
exports.accountFromAny = accountFromAny; //# sourceMappingURL=accounts.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/aminotypes.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AminoTypes = void 0;
/**
 * A map from Stargate message types as used in the messages's `Any` type
 * to Amino types.
 */ class AminoTypes {
    constructor(types){
        this.register = types;
    }
    toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
            throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. ` + "If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. " + "If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.");
        }
        return {
            type: converter.aminoType,
            value: converter.toAmino(value)
        };
    }
    fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }])=>aminoType === type);
        switch(matches.length){
            case 0:
                {
                    throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. ` + "If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. " + "If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.");
                }
            case 1:
                {
                    const [typeUrl, converter] = matches[0];
                    return {
                        typeUrl: typeUrl,
                        value: converter.fromAmino(value)
                    };
                }
            default:
                throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value])=>key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
    }
}
exports.AminoTypes = AminoTypes; //# sourceMappingURL=aminotypes.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/events.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromTendermintEvent = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
/**
 * Takes a Tendermint 0.34 or 0.37 event with binary encoded key and value
 * and converts it into an `Event` with string attributes.
 */ function fromTendermintEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes.map((attr)=>({
                key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
                value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
            }))
    };
}
exports.fromTendermintEvent = fromTendermintEvent; //# sourceMappingURL=events.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/fee.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateFee = exports.GasPrice = void 0;
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
/**
 * Denom checker for the Cosmos SDK 0.42 denom pattern
 * (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
 *
 * This is like a regexp but with helpful error messages.
 */ function checkDenom(denom) {
    if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
    }
}
/**
 * A gas price, i.e. the price of a single unit of gas. This is typically a fraction of
 * the smallest fee token unit, such as 0.012utoken.
 */ class GasPrice {
    constructor(amount, denom){
        this.amount = amount;
        this.denom = denom;
    }
    /**
     * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
     *
     * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
     * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
     *
     * Separators are not yet supported.
     */ static fromString(gasPrice) {
        // Use Decimal.fromUserInput and checkDenom for detailed checks and helpful error messages
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
            throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new GasPrice(decimalAmount, denom);
    }
    /**
     * Returns a string representation of this gas price, e.g. "0.025uatom".
     * This can be used as an input to `GasPrice.fromString`.
     */ toString() {
        return this.amount.toString() + this.denom;
    }
}
exports.GasPrice = GasPrice;
function calculateFee(gasLimit, gasPrice) {
    const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
    const { denom, amount: gasPriceAmount } = processedGasPrice;
    // Note: Amount can exceed the safe integer range (https://github.com/cosmos/cosmjs/issues/1134),
    // which we handle by converting from Decimal to string without going through number.
    const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
    return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
    };
}
exports.calculateFee = calculateFee; //# sourceMappingURL=fee.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/logs.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findAttribute = exports.parseRawLog = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
function parseAttribute(input) {
    if (!(0, utils_1.isNonNullObject)(input)) throw new Error("Attribute must be a non-null object");
    const { key, value } = input;
    if (typeof key !== "string" || !key) throw new Error("Attribute's key must be a non-empty string");
    if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
    }
    return {
        key: key,
        value: value || ""
    };
}
exports.parseAttribute = parseAttribute;
function parseEvent(input) {
    if (!(0, utils_1.isNonNullObject)(input)) throw new Error("Event must be a non-null object");
    const { type, attributes } = input;
    if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
    }
    if (!Array.isArray(attributes)) throw new Error("Event's attributes must be an array");
    return {
        type: type,
        attributes: attributes.map(parseAttribute)
    };
}
exports.parseEvent = parseEvent;
function parseLog(input) {
    if (!(0, utils_1.isNonNullObject)(input)) throw new Error("Log must be a non-null object");
    const { msg_index, log, events } = input;
    if (typeof msg_index !== "number") throw new Error("Log's msg_index must be a number");
    if (typeof log !== "string") throw new Error("Log's log must be a string");
    if (!Array.isArray(events)) throw new Error("Log's events must be an array");
    return {
        msg_index: msg_index,
        log: log,
        events: events.map(parseEvent)
    };
}
exports.parseLog = parseLog;
function parseLogs(input) {
    if (!Array.isArray(input)) throw new Error("Logs must be an array");
    return input.map(parseLog);
}
exports.parseLogs = parseLogs;
function parseRawLog(input) {
    // Cosmos SDK >= 0.50 gives us an empty string here. This should be handled like undefined.
    if (!input) return [];
    const logsToParse = JSON.parse(input).map(({ events }, i)=>({
            msg_index: i,
            events,
            log: ""
        }));
    return parseLogs(logsToParse);
}
exports.parseRawLog = parseRawLog;
/**
 * Searches in logs for the first event of the given event type and in that event
 * for the first first attribute with the given attribute key.
 *
 * Throws if the attribute was not found.
 */ function findAttribute(logs, eventType, attrKey) {
    const firstLogs = logs.find(()=>true);
    const out = firstLogs?.events.find((event)=>event.type === eventType)?.attributes.find((attr)=>attr.key === attrKey);
    if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
    }
    return out;
}
exports.findAttribute = findAttribute; //# sourceMappingURL=logs.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryClient = void 0;
/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */ const ics23_1 = __turbopack_context__.r("[project]/node_modules/@confio/ics23/build/index.js [client] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stream/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
function checkAndParseOp(op, kind, key) {
    if (op.type !== kind) {
        throw new Error(`Op expected to be ${kind}, got "${op.type}`);
    }
    if (!(0, utils_1.arrayContentEquals)(key, op.key)) {
        throw new Error(`Proven key different than queried key.\nQuery: ${(0, encoding_1.toHex)(key)}\nProven: ${(0, encoding_1.toHex)(op.key)}`);
    }
    return ics23_1.ics23.CommitmentProof.decode(op.data);
}
class QueryClient {
    static withExtensions(cometClient, ...extensionSetups) {
        const client = new QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension)=>setupExtension(client));
        for (const extension of extensions){
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
            for (const [moduleKey, moduleValue] of Object.entries(extension)){
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
                const current = client[moduleKey] || {};
                client[moduleKey] = {
                    ...current,
                    ...moduleValue
                };
            }
        }
        return client;
    }
    constructor(cometClient){
        this.cometClient = cometClient;
    }
    /**
     * Queries the database store with a proof, which is then verified.
     *
     * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
     */ async queryStoreVerified(store, queryKey, desiredHeight) {
        const { height, proof, key, value } = await this.queryRawProof(store, queryKey, desiredHeight);
        const subProof = checkAndParseOp(proof.ops[0], "ics23:iavl", queryKey);
        const storeProof = checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        // this must always be existence, if the store is not a typo
        (0, utils_1.assert)(storeProof.exist);
        (0, utils_1.assert)(storeProof.exist.value);
        // this may be exist or non-exist, depends on response
        if (!value || value.length === 0) {
            // non-existence check
            (0, utils_1.assert)(subProof.nonexist);
            // the subproof must map the desired key to the "value" of the storeProof
            (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, queryKey);
        } else {
            // existence check
            (0, utils_1.assert)(subProof.exist);
            (0, utils_1.assert)(subProof.exist.value);
            // the subproof must map the desired key to the "value" of the storeProof
            (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, queryKey, value);
        }
        // the store proof must map its declared value (root of subProof) to the appHash of the next block
        const header = await this.getNextHeader(height);
        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);
        return {
            key,
            value,
            height
        };
    }
    async queryRawProof(store, queryKey, desiredHeight) {
        const { key, value, height, proof, code, log } = await this.cometClient.abciQuery({
            // we need the StoreKey for the module, not the module name
            // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
            path: `/store/${store}/key`,
            data: queryKey,
            prove: true,
            height: desiredHeight
        });
        if (code) {
            throw new Error(`Query failed with (${code}): ${log}`);
        }
        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {
            throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);
        }
        if (!height) {
            throw new Error("No query height returned");
        }
        if (!proof || proof.ops.length !== 2) {
            throw new Error(`Expected 2 proof ops, got ${proof?.ops.length ?? 0}. Are you using stargate?`);
        }
        // we don't need the results, but we can ensure the data is the proper format
        checkAndParseOp(proof.ops[0], "ics23:iavl", key);
        checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        return {
            key: key,
            value: value,
            height: height,
            // need to clone this: readonly input / writeable output
            proof: {
                ops: [
                    ...proof.ops
                ]
            }
        };
    }
    /**
     * Performs an ABCI query to Tendermint without requesting a proof.
     *
     * If the `desiredHeight` is set, a particular height is requested. Otherwise
     * the latest height is requested. The response contains the actual height of
     * the query.
     */ async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
            path: path,
            data: request,
            prove: false,
            height: desiredHeight
        });
        if (response.code) {
            throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
            throw new Error("No query height returned");
        }
        return {
            value: response.value,
            height: response.height
        };
    }
    // this must return the header for height+1
    // throws an error if height is 0 or undefined
    async getNextHeader(height) {
        (0, utils_1.assertDefined)(height);
        if (height === 0) {
            throw new Error("Query returned height 0, cannot prove it");
        }
        const searchHeight = height + 1;
        let nextHeader;
        let headersSubscription;
        try {
            headersSubscription = this.cometClient.subscribeNewBlockHeader();
        } catch  {
        // Ignore exception caused by non-WebSocket Tendermint clients
        }
        if (headersSubscription) {
            const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);
            // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.
            if (firstHeader.height === searchHeight) {
                nextHeader = firstHeader;
            }
        }
        while(!nextHeader){
            // start from current height to avoid backend error for minHeight in the future
            const correctHeader = (await this.cometClient.blockchain(height, searchHeight)).blockMetas.map((meta)=>meta.header).find((h)=>h.height === searchHeight);
            if (correctHeader) {
                nextHeader = correctHeader;
            } else {
                await (0, utils_1.sleep)(1000);
            }
        }
        (0, utils_1.assert)(nextHeader.height === searchHeight, "Got wrong header. This is a bug in the logic above.");
        return nextHeader;
    }
}
exports.QueryClient = QueryClient; //# sourceMappingURL=queryclient.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/queryclient/utils.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeCosmosSdkDecFromProto = exports.longify = exports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js [client] (ecmascript)");
/**
 * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.
 * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.
 * The result is typically 20 bytes long but not restricted to that.
 */ function toAccAddress(address) {
    return (0, encoding_1.fromBech32)(address).data;
}
exports.toAccAddress = toAccAddress;
/**
 * If paginationKey is set, return a `PageRequest` with the given key.
 * If paginationKey is unset, return `undefined`.
 *
 * Use this with a query response's pagination next key to
 * request the next page.
 */ function createPagination(paginationKey) {
    return paginationKey ? pagination_1.PageRequest.fromPartial({
        key: paginationKey
    }) : pagination_1.PageRequest.fromPartial({});
}
exports.createPagination = createPagination;
function createProtobufRpcClient(base) {
    return {
        request: async (service, method, data)=>{
            const path = `/${service}/${method}`;
            const response = await base.queryAbci(path, data, undefined);
            return response.value;
        }
    };
}
exports.createProtobufRpcClient = createProtobufRpcClient;
/**
 * Takes a uint64 value as string, number, BigInt or Uint64 and returns a BigInt
 * of it.
 */ function longify(value) {
    const checkedValue = math_1.Uint64.fromString(value.toString());
    return BigInt(checkedValue.toString());
}
exports.longify = longify;
/**
 * Takes a string or binary encoded `github.com/cosmos/cosmos-sdk/types.Dec` from the
 * protobuf API and converts it into a `Decimal` with 18 fractional digits.
 *
 * See https://github.com/cosmos/cosmos-sdk/issues/10863 for more context why this is needed.
 */ function decodeCosmosSdkDecFromProto(input) {
    const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
    return math_1.Decimal.fromAtomics(asString, 18);
}
exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.longify = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.QueryClient = void 0;
var queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js [client] (ecmascript)");
Object.defineProperty(exports, "QueryClient", {
    enumerable: true,
    get: function() {
        return queryclient_1.QueryClient;
    }
});
var utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/utils.js [client] (ecmascript)");
Object.defineProperty(exports, "createPagination", {
    enumerable: true,
    get: function() {
        return utils_1.createPagination;
    }
});
Object.defineProperty(exports, "createProtobufRpcClient", {
    enumerable: true,
    get: function() {
        return utils_1.createProtobufRpcClient;
    }
});
Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", {
    enumerable: true,
    get: function() {
        return utils_1.decodeCosmosSdkDecFromProto;
    }
});
Object.defineProperty(exports, "longify", {
    enumerable: true,
    get: function() {
        return utils_1.longify;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/auth/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupAuthExtension = void 0;
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupAuthExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        auth: {
            account: async (address)=>{
                const { account } = await queryService.Account({
                    address: address
                });
                return account ?? null;
            }
        }
    };
}
exports.setupAuthExtension = setupAuthExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAuthzAminoConverters = void 0;
function createAuthzAminoConverters() {
    return {
    };
}
exports.createAuthzAminoConverters = createAuthzAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/authz/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.authzTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js [client] (ecmascript)");
exports.authzTypes = [
    [
        "/cosmos.authz.v1beta1.MsgExec",
        tx_1.MsgExec
    ],
    [
        "/cosmos.authz.v1beta1.MsgGrant",
        tx_1.MsgGrant
    ],
    [
        "/cosmos.authz.v1beta1.MsgRevoke",
        tx_1.MsgRevoke
    ]
]; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/authz/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupAuthzExtension = void 0;
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupAuthzExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        authz: {
            grants: async (granter, grantee, msgTypeUrl, paginationKey)=>{
                return await queryService.Grants({
                    granter: granter,
                    grantee: grantee,
                    msgTypeUrl: msgTypeUrl,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
            },
            granteeGrants: async (grantee, paginationKey)=>{
                return await queryService.GranteeGrants({
                    grantee: grantee,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
            },
            granterGrants: async (granter, paginationKey)=>{
                return await queryService.GranterGrants({
                    granter: granter,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
            }
        }
    };
}
exports.setupAuthzExtension = setupAuthzExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createBankAminoConverters = exports.isAminoMsgMultiSend = exports.isAminoMsgSend = void 0;
function isAminoMsgSend(msg) {
    return msg.type === "cosmos-sdk/MsgSend";
}
exports.isAminoMsgSend = isAminoMsgSend;
function isAminoMsgMultiSend(msg) {
    return msg.type === "cosmos-sdk/MsgMultiSend";
}
exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
function createBankAminoConverters() {
    return {
        "/cosmos.bank.v1beta1.MsgSend": {
            aminoType: "cosmos-sdk/MsgSend",
            toAmino: ({ fromAddress, toAddress, amount })=>({
                    from_address: fromAddress,
                    to_address: toAddress,
                    amount: [
                        ...amount
                    ]
                }),
            fromAmino: ({ from_address, to_address, amount })=>({
                    fromAddress: from_address,
                    toAddress: to_address,
                    amount: [
                        ...amount
                    ]
                })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
            aminoType: "cosmos-sdk/MsgMultiSend",
            toAmino: ({ inputs, outputs })=>({
                    inputs: inputs.map((input)=>({
                            address: input.address,
                            coins: [
                                ...input.coins
                            ]
                        })),
                    outputs: outputs.map((output)=>({
                            address: output.address,
                            coins: [
                                ...output.coins
                            ]
                        }))
                }),
            fromAmino: ({ inputs, outputs })=>({
                    inputs: inputs.map((input)=>({
                            address: input.address,
                            coins: [
                                ...input.coins
                            ]
                        })),
                    outputs: outputs.map((output)=>({
                            address: output.address,
                            coins: [
                                ...output.coins
                            ]
                        }))
                })
        }
    };
}
exports.createBankAminoConverters = createBankAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/bank/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgSendEncodeObject = exports.bankTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js [client] (ecmascript)");
exports.bankTypes = [
    [
        "/cosmos.bank.v1beta1.MsgMultiSend",
        tx_1.MsgMultiSend
    ],
    [
        "/cosmos.bank.v1beta1.MsgSend",
        tx_1.MsgSend
    ]
];
function isMsgSendEncodeObject(encodeObject) {
    return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
}
exports.isMsgSendEncodeObject = isMsgSendEncodeObject; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/bank/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupBankExtension = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupBankExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        bank: {
            balance: async (address, denom)=>{
                const { balance } = await queryService.Balance({
                    address: address,
                    denom: denom
                });
                (0, utils_1.assert)(balance);
                return balance;
            },
            allBalances: async (address)=>{
                const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({
                    address: address
                }));
                return balances;
            },
            totalSupply: async (paginationKey)=>{
                const response = await queryService.TotalSupply({
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            supplyOf: async (denom)=>{
                const { amount } = await queryService.SupplyOf({
                    denom: denom
                });
                (0, utils_1.assert)(amount);
                return amount;
            },
            denomMetadata: async (denom)=>{
                const { metadata } = await queryService.DenomMetadata({
                    denom
                });
                (0, utils_1.assert)(metadata);
                return metadata;
            },
            denomsMetadata: async ()=>{
                const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
                    pagination: undefined
                }));
                return metadatas;
            }
        }
    };
}
exports.setupBankExtension = setupBankExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCrysisAminoConverters = exports.isAminoMsgVerifyInvariant = void 0;
function isAminoMsgVerifyInvariant(msg) {
    return msg.type === "cosmos-sdk/MsgVerifyInvariant";
}
exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
function createCrysisAminoConverters() {
    throw new Error("Not implemented");
}
exports.createCrysisAminoConverters = createCrysisAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createDistributionAminoConverters = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = void 0;
function isAminoMsgSetWithdrawAddress(msg) {
    // NOTE: Type string and names diverge here!
    return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
}
exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
function isAminoMsgWithdrawDelegatorReward(msg) {
    // NOTE: Type string and names diverge here!
    return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
}
exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
function isAminoMsgWithdrawValidatorCommission(msg) {
    return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
}
exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
function isAminoMsgFundCommunityPool(msg) {
    return msg.type === "cosmos-sdk/MsgFundCommunityPool";
}
exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
function createDistributionAminoConverters() {
    return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
            aminoType: "cosmos-sdk/MsgFundCommunityPool",
            toAmino: ({ amount, depositor })=>({
                    amount: [
                        ...amount
                    ],
                    depositor: depositor
                }),
            fromAmino: ({ amount, depositor })=>({
                    amount: [
                        ...amount
                    ],
                    depositor: depositor
                })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
            aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
            toAmino: ({ delegatorAddress, withdrawAddress })=>({
                    delegator_address: delegatorAddress,
                    withdraw_address: withdrawAddress
                }),
            fromAmino: ({ delegator_address, withdraw_address })=>({
                    delegatorAddress: delegator_address,
                    withdrawAddress: withdraw_address
                })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
            aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
            toAmino: ({ delegatorAddress, validatorAddress })=>({
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress
                }),
            fromAmino: ({ delegator_address, validator_address })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address
                })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
            aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
            toAmino: ({ validatorAddress })=>({
                    validator_address: validatorAddress
                }),
            fromAmino: ({ validator_address })=>({
                    validatorAddress: validator_address
                })
        }
    };
}
exports.createDistributionAminoConverters = createDistributionAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js [client] (ecmascript)");
exports.distributionTypes = [
    [
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
        tx_1.MsgFundCommunityPool
    ],
    [
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
        tx_1.MsgSetWithdrawAddress
    ],
    [
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        tx_1.MsgWithdrawDelegatorReward
    ],
    [
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
        tx_1.MsgWithdrawValidatorCommission
    ]
];
function isMsgWithdrawDelegatorRewardEncodeObject(object) {
    return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}
exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupDistributionExtension = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupDistributionExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        distribution: {
            communityPool: async ()=>{
                const response = await queryService.CommunityPool({});
                return response;
            },
            delegationRewards: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.DelegationRewards({
                    delegatorAddress: delegatorAddress,
                    validatorAddress: validatorAddress
                });
                return response;
            },
            delegationTotalRewards: async (delegatorAddress)=>{
                const response = await queryService.DelegationTotalRewards({
                    delegatorAddress: delegatorAddress
                });
                return response;
            },
            delegatorValidators: async (delegatorAddress)=>{
                const response = await queryService.DelegatorValidators({
                    delegatorAddress: delegatorAddress
                });
                return response;
            },
            delegatorWithdrawAddress: async (delegatorAddress)=>{
                const response = await queryService.DelegatorWithdrawAddress({
                    delegatorAddress: delegatorAddress
                });
                return response;
            },
            params: async ()=>{
                const response = await queryService.Params({});
                return response;
            },
            validatorCommission: async (validatorAddress)=>{
                const response = await queryService.ValidatorCommission({
                    validatorAddress: validatorAddress
                });
                return response;
            },
            validatorOutstandingRewards: async (validatorAddress)=>{
                const response = await queryService.ValidatorOutstandingRewards({
                    validatorAddress: validatorAddress
                });
                return response;
            },
            validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey)=>{
                const response = await queryService.ValidatorSlashes({
                    validatorAddress: validatorAddress,
                    startingHeight: BigInt(startingHeight),
                    endingHeight: BigInt(endingHeight),
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            }
        }
    };
}
exports.setupDistributionExtension = setupDistributionExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createEvidenceAminoConverters = exports.isAminoMsgSubmitEvidence = void 0;
function isAminoMsgSubmitEvidence(msg) {
    return msg.type === "cosmos-sdk/MsgSubmitEvidence";
}
exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
function createEvidenceAminoConverters() {
    throw new Error("Not implemented");
}
exports.createEvidenceAminoConverters = createEvidenceAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createFeegrantAminoConverters = void 0;
function createFeegrantAminoConverters() {
    return {
    };
}
exports.createFeegrantAminoConverters = createFeegrantAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.feegrantTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js [client] (ecmascript)");
exports.feegrantTypes = [
    [
        "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
        tx_1.MsgGrantAllowance
    ],
    [
        "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
        tx_1.MsgRevokeAllowance
    ]
]; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupFeegrantExtension = void 0;
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupFeegrantExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        feegrant: {
            allowance: async (granter, grantee)=>{
                const response = await queryService.Allowance({
                    granter: granter,
                    grantee: grantee
                });
                return response;
            },
            allowances: async (grantee, paginationKey)=>{
                const response = await queryService.Allowances({
                    grantee: grantee,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            }
        }
    };
}
exports.setupFeegrantExtension = setupFeegrantExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createGovAminoConverters = exports.isAminoMsgDeposit = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = void 0;
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const gov_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js [client] (ecmascript)");
const any_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/google/protobuf/any.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function isAminoMsgSubmitProposal(msg) {
    return msg.type === "cosmos-sdk/MsgSubmitProposal";
}
exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
function isAminoMsgVote(msg) {
    return msg.type === "cosmos-sdk/MsgVote";
}
exports.isAminoMsgVote = isAminoMsgVote;
function isAminoMsgVoteWeighted(msg) {
    return msg.type === "cosmos-sdk/MsgVoteWeighted";
}
exports.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
function isAminoMsgDeposit(msg) {
    return msg.type === "cosmos-sdk/MsgDeposit";
}
exports.isAminoMsgDeposit = isAminoMsgDeposit;
function createGovAminoConverters() {
    // Gov v1 types missing, see
    // https://github.com/cosmos/cosmjs/issues/1442
    return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
            aminoType: "cosmos-sdk/MsgDeposit",
            toAmino: ({ amount, depositor, proposalId })=>{
                return {
                    amount,
                    depositor,
                    proposal_id: proposalId.toString()
                };
            },
            fromAmino: ({ amount, depositor, proposal_id })=>{
                return {
                    amount: Array.from(amount),
                    depositor,
                    proposalId: BigInt(proposal_id)
                };
            }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
            aminoType: "cosmos-sdk/MsgVote",
            toAmino: ({ option, proposalId, voter })=>{
                return {
                    option: option,
                    proposal_id: proposalId.toString(),
                    voter: voter
                };
            },
            fromAmino: ({ option, proposal_id, voter })=>{
                return {
                    option: (0, gov_1.voteOptionFromJSON)(option),
                    proposalId: BigInt(proposal_id),
                    voter: voter
                };
            }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
            aminoType: "cosmos-sdk/MsgVoteWeighted",
            toAmino: ({ options, proposalId, voter })=>{
                return {
                    options: options.map((o)=>({
                            option: o.option,
                            // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                            // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                            weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
                        })),
                    proposal_id: proposalId.toString(),
                    voter: voter
                };
            },
            fromAmino: ({ options, proposal_id, voter })=>{
                return {
                    proposalId: BigInt(proposal_id),
                    voter: voter,
                    options: options.map((o)=>({
                            option: (0, gov_1.voteOptionFromJSON)(o.option),
                            weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
                        }))
                };
            }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
            aminoType: "cosmos-sdk/MsgSubmitProposal",
            toAmino: ({ initialDeposit, proposer, content })=>{
                (0, utils_1.assertDefinedAndNotNull)(content);
                let proposal;
                switch(content.typeUrl){
                    case "/cosmos.gov.v1beta1.TextProposal":
                        {
                            const textProposal = gov_1.TextProposal.decode(content.value);
                            proposal = {
                                type: "cosmos-sdk/TextProposal",
                                value: {
                                    description: textProposal.description,
                                    title: textProposal.title
                                }
                            };
                            break;
                        }
                    default:
                        throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
                }
                return {
                    initial_deposit: initialDeposit,
                    proposer: proposer,
                    content: proposal
                };
            },
            fromAmino: ({ initial_deposit, proposer, content })=>{
                let any_content;
                switch(content.type){
                    case "cosmos-sdk/TextProposal":
                        {
                            const { value } = content;
                            (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                            const { title, description } = value;
                            (0, utils_1.assert)(typeof title === "string");
                            (0, utils_1.assert)(typeof description === "string");
                            any_content = any_1.Any.fromPartial({
                                typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                                value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                                    title: title,
                                    description: description
                                })).finish()
                            });
                            break;
                        }
                    default:
                        throw new Error(`Unsupported proposal type: '${content.type}'`);
                }
                return {
                    initialDeposit: Array.from(initial_deposit),
                    proposer: proposer,
                    content: any_content
                };
            }
        }
    };
}
exports.createGovAminoConverters = createGovAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/gov/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/gov/v1/tx.js [client] (ecmascript)");
const tx_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js [client] (ecmascript)");
exports.govTypes = [
    [
        "/cosmos.gov.v1.MsgDeposit",
        tx_1.MsgDeposit
    ],
    [
        "/cosmos.gov.v1.MsgSubmitProposal",
        tx_1.MsgSubmitProposal
    ],
    [
        "/cosmos.gov.v1.MsgUpdateParams",
        tx_1.MsgUpdateParams
    ],
    [
        "/cosmos.gov.v1.MsgVote",
        tx_1.MsgVote
    ],
    [
        "/cosmos.gov.v1.MsgVoteWeighted",
        tx_1.MsgVoteWeighted
    ],
    [
        "/cosmos.gov.v1beta1.MsgDeposit",
        tx_2.MsgDeposit
    ],
    [
        "/cosmos.gov.v1beta1.MsgSubmitProposal",
        tx_2.MsgSubmitProposal
    ],
    [
        "/cosmos.gov.v1beta1.MsgVote",
        tx_2.MsgVote
    ],
    [
        "/cosmos.gov.v1beta1.MsgVoteWeighted",
        tx_2.MsgVoteWeighted
    ]
];
function isMsgDepositEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
}
exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
function isMsgSubmitProposalEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
}
exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
function isMsgVoteEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
}
exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
function isMsgVoteWeightedEncodeObject(object) {
    return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
}
exports.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/gov/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupGovExtension = void 0;
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupGovExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        gov: {
            params: async (parametersType)=>{
                const response = await queryService.Params({
                    paramsType: parametersType
                });
                return response;
            },
            proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey)=>{
                const response = await queryService.Proposals({
                    proposalStatus,
                    depositor: depositorAddress,
                    voter: voterAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            proposal: async (proposalId)=>{
                const response = await queryService.Proposal({
                    proposalId: (0, queryclient_1.longify)(proposalId)
                });
                return response;
            },
            deposits: async (proposalId, paginationKey)=>{
                const response = await queryService.Deposits({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            deposit: async (proposalId, depositorAddress)=>{
                const response = await queryService.Deposit({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    depositor: depositorAddress
                });
                return response;
            },
            tally: async (proposalId)=>{
                const response = await queryService.TallyResult({
                    proposalId: (0, queryclient_1.longify)(proposalId)
                });
                return response;
            },
            votes: async (proposalId, paginationKey)=>{
                const response = await queryService.Votes({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            vote: async (proposalId, voterAddress)=>{
                const response = await queryService.Vote({
                    proposalId: (0, queryclient_1.longify)(proposalId),
                    voter: voterAddress
                });
                return response;
            }
        }
    };
}
exports.setupGovExtension = setupGovExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createGroupAminoConverters = void 0;
function createGroupAminoConverters() {
    // Missing, see https://github.com/cosmos/cosmjs/issues/1441
    return {};
}
exports.createGroupAminoConverters = createGroupAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/group/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.groupTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/group/v1/tx.js [client] (ecmascript)");
exports.groupTypes = [
    [
        "/cosmos.group.v1.MsgCreateGroup",
        tx_1.MsgCreateGroup
    ],
    [
        "/cosmos.group.v1.MsgCreateGroupPolicy",
        tx_1.MsgCreateGroupPolicy
    ],
    [
        "/cosmos.group.v1.MsgCreateGroupWithPolicy",
        tx_1.MsgCreateGroupWithPolicy
    ],
    [
        "/cosmos.group.v1.MsgExec",
        tx_1.MsgExec
    ],
    [
        "/cosmos.group.v1.MsgLeaveGroup",
        tx_1.MsgLeaveGroup
    ],
    [
        "/cosmos.group.v1.MsgSubmitProposal",
        tx_1.MsgSubmitProposal
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupAdmin",
        tx_1.MsgUpdateGroupAdmin
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupMembers",
        tx_1.MsgUpdateGroupMembers
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupMetadata",
        tx_1.MsgUpdateGroupMetadata
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
        tx_1.MsgUpdateGroupPolicyAdmin
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
        tx_1.MsgUpdateGroupPolicyDecisionPolicy
    ],
    [
        "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
        tx_1.MsgUpdateGroupPolicyMetadata
    ],
    [
        "/cosmos.group.v1.MsgVote",
        tx_1.MsgVote
    ],
    [
        "/cosmos.group.v1.MsgWithdrawProposal",
        tx_1.MsgWithdrawProposal
    ]
]; // There are no EncodeObject implementations for the new v1 message types because
 // those things don't scale (https://github.com/cosmos/cosmjs/issues/1440). We need to
 // address this more fundamentally. Users can use
 // const msg = {
 //   typeUrl: "/cosmos.group.v1.MsgCreateGroup",
 //   value: MsgCreateGroup.fromPartial({ ... })
 // }
 // in their app.
 //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createIbcAminoConverters = exports.isAminoMsgTransfer = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const amino_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/amino/build/index.js [client] (ecmascript)");
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js [client] (ecmascript)");
function isAminoMsgTransfer(msg) {
    return msg.type === "cosmos-sdk/MsgTransfer";
}
exports.isAminoMsgTransfer = isAminoMsgTransfer;
function createIbcAminoConverters() {
    return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
            aminoType: "cosmos-sdk/MsgTransfer",
            toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo })=>({
                    source_port: sourcePort,
                    source_channel: sourceChannel,
                    token: token,
                    sender: sender,
                    receiver: receiver,
                    timeout_height: timeoutHeight ? {
                        revision_height: (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)?.toString(),
                        revision_number: (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)?.toString()
                    } : {},
                    timeout_timestamp: (0, amino_1.omitDefault)(timeoutTimestamp)?.toString(),
                    memo: (0, amino_1.omitDefault)(memo)
                }),
            fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo })=>tx_1.MsgTransfer.fromPartial({
                    sourcePort: source_port,
                    sourceChannel: source_channel,
                    token: token,
                    sender: sender,
                    receiver: receiver,
                    timeoutHeight: timeout_height ? {
                        revisionHeight: BigInt(timeout_height.revision_height || "0"),
                        revisionNumber: BigInt(timeout_height.revision_number || "0")
                    } : undefined,
                    timeoutTimestamp: BigInt(timeout_timestamp || "0"),
                    memo: memo ?? ""
                })
        }
    };
}
exports.createIbcAminoConverters = createIbcAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgTransferEncodeObject = exports.ibcTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js [client] (ecmascript)");
const tx_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/channel/v1/tx.js [client] (ecmascript)");
const tx_3 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/client/v1/tx.js [client] (ecmascript)");
const tx_4 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/connection/v1/tx.js [client] (ecmascript)");
exports.ibcTypes = [
    [
        "/ibc.applications.transfer.v1.MsgTransfer",
        tx_1.MsgTransfer
    ],
    [
        "/ibc.core.channel.v1.MsgAcknowledgement",
        tx_2.MsgAcknowledgement
    ],
    [
        "/ibc.core.channel.v1.MsgChannelCloseConfirm",
        tx_2.MsgChannelCloseConfirm
    ],
    [
        "/ibc.core.channel.v1.MsgChannelCloseInit",
        tx_2.MsgChannelCloseInit
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenAck",
        tx_2.MsgChannelOpenAck
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenConfirm",
        tx_2.MsgChannelOpenConfirm
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenInit",
        tx_2.MsgChannelOpenInit
    ],
    [
        "/ibc.core.channel.v1.MsgChannelOpenTry",
        tx_2.MsgChannelOpenTry
    ],
    [
        "/ibc.core.channel.v1.MsgRecvPacket",
        tx_2.MsgRecvPacket
    ],
    [
        "/ibc.core.channel.v1.MsgTimeout",
        tx_2.MsgTimeout
    ],
    [
        "/ibc.core.channel.v1.MsgTimeoutOnClose",
        tx_2.MsgTimeoutOnClose
    ],
    [
        "/ibc.core.client.v1.MsgCreateClient",
        tx_3.MsgCreateClient
    ],
    [
        "/ibc.core.client.v1.MsgSubmitMisbehaviour",
        tx_3.MsgSubmitMisbehaviour
    ],
    [
        "/ibc.core.client.v1.MsgUpdateClient",
        tx_3.MsgUpdateClient
    ],
    [
        "/ibc.core.client.v1.MsgUpgradeClient",
        tx_3.MsgUpgradeClient
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenAck",
        tx_4.MsgConnectionOpenAck
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
        tx_4.MsgConnectionOpenConfirm
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenInit",
        tx_4.MsgConnectionOpenInit
    ],
    [
        "/ibc.core.connection.v1.MsgConnectionOpenTry",
        tx_4.MsgConnectionOpenTry
    ]
];
function isMsgTransferEncodeObject(object) {
    return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
}
exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupIbcExtension = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js [client] (ecmascript)");
const channel_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/channel/v1/channel.js [client] (ecmascript)");
const query_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/channel/v1/query.js [client] (ecmascript)");
const query_3 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/client/v1/query.js [client] (ecmascript)");
const query_4 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/core/connection/v1/query.js [client] (ecmascript)");
const tendermint_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function decodeTendermintClientStateAny(clientState) {
    if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
    }
    return tendermint_1.ClientState.decode(clientState.value);
}
function decodeTendermintConsensusStateAny(clientState) {
    if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
    }
    return tendermint_1.ConsensusState.decode(clientState.value);
}
function setupIbcExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use these services to get easy typed access to query methods
    // These cannot be used for proof verification
    const channelQueryService = new query_2.QueryClientImpl(rpc);
    const clientQueryService = new query_3.QueryClientImpl(rpc);
    const connectionQueryService = new query_4.QueryClientImpl(rpc);
    const transferQueryService = new query_1.QueryClientImpl(rpc);
    return {
        ibc: {
            channel: {
                channel: async (portId, channelId)=>channelQueryService.Channel({
                        portId: portId,
                        channelId: channelId
                    }),
                channels: async (paginationKey)=>channelQueryService.Channels({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allChannels: async ()=>{
                    const channels = [];
                    let response;
                    let key;
                    do {
                        response = await channelQueryService.Channels({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        channels.push(...response.channels);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_2.QueryChannelsResponse.fromPartial({
                        channels: channels,
                        height: response.height
                    });
                },
                connectionChannels: async (connection, paginationKey)=>channelQueryService.ConnectionChannels({
                        connection: connection,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allConnectionChannels: async (connection)=>{
                    const channels = [];
                    let response;
                    let key;
                    do {
                        response = await channelQueryService.ConnectionChannels({
                            connection: connection,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        channels.push(...response.channels);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_2.QueryConnectionChannelsResponse.fromPartial({
                        channels: channels,
                        height: response.height
                    });
                },
                clientState: async (portId, channelId)=>channelQueryService.ChannelClientState({
                        portId: portId,
                        channelId: channelId
                    }),
                consensusState: async (portId, channelId, revisionNumber, revisionHeight)=>channelQueryService.ChannelConsensusState({
                        portId: portId,
                        channelId: channelId,
                        revisionNumber: BigInt(revisionNumber),
                        revisionHeight: BigInt(revisionHeight)
                    }),
                packetCommitment: async (portId, channelId, sequence)=>channelQueryService.PacketCommitment({
                        portId: portId,
                        channelId: channelId,
                        sequence: (0, queryclient_1.longify)(sequence)
                    }),
                packetCommitments: async (portId, channelId, paginationKey)=>channelQueryService.PacketCommitments({
                        channelId: channelId,
                        portId: portId,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allPacketCommitments: async (portId, channelId)=>{
                    const commitments = [];
                    let response;
                    let key;
                    do {
                        response = await channelQueryService.PacketCommitments({
                            channelId: channelId,
                            portId: portId,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        commitments.push(...response.commitments);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_2.QueryPacketCommitmentsResponse.fromPartial({
                        commitments: commitments,
                        height: response.height
                    });
                },
                packetReceipt: async (portId, channelId, sequence)=>channelQueryService.PacketReceipt({
                        portId: portId,
                        channelId: channelId,
                        sequence: (0, queryclient_1.longify)(sequence)
                    }),
                packetAcknowledgement: async (portId, channelId, sequence)=>channelQueryService.PacketAcknowledgement({
                        portId: portId,
                        channelId: channelId,
                        sequence: (0, queryclient_1.longify)(sequence)
                    }),
                packetAcknowledgements: async (portId, channelId, paginationKey)=>{
                    const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                        portId: portId,
                        channelId: channelId,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    });
                    return channelQueryService.PacketAcknowledgements(request);
                },
                allPacketAcknowledgements: async (portId, channelId)=>{
                    const acknowledgements = [];
                    let response;
                    let key;
                    do {
                        const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                            channelId: channelId,
                            portId: portId,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        response = await channelQueryService.PacketAcknowledgements(request);
                        acknowledgements.push(...response.acknowledgements);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                        acknowledgements: acknowledgements,
                        height: response.height
                    });
                },
                unreceivedPackets: async (portId, channelId, packetCommitmentSequences)=>channelQueryService.UnreceivedPackets({
                        portId: portId,
                        channelId: channelId,
                        packetCommitmentSequences: packetCommitmentSequences.map((s)=>BigInt(s))
                    }),
                unreceivedAcks: async (portId, channelId, packetAckSequences)=>channelQueryService.UnreceivedAcks({
                        portId: portId,
                        channelId: channelId,
                        packetAckSequences: packetAckSequences.map((s)=>BigInt(s))
                    }),
                nextSequenceReceive: async (portId, channelId)=>channelQueryService.NextSequenceReceive({
                        portId: portId,
                        channelId: channelId
                    })
            },
            client: {
                state: async (clientId)=>clientQueryService.ClientState({
                        clientId
                    }),
                states: async (paginationKey)=>clientQueryService.ClientStates({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allStates: async ()=>{
                    const clientStates = [];
                    let response;
                    let key;
                    do {
                        response = await clientQueryService.ClientStates({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        clientStates.push(...response.clientStates);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_3.QueryClientStatesResponse.fromPartial({
                        clientStates: clientStates
                    });
                },
                consensusState: async (clientId, consensusHeight)=>clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                        clientId: clientId,
                        revisionHeight: consensusHeight !== undefined ? BigInt(consensusHeight) : undefined,
                        latestHeight: consensusHeight === undefined
                    })),
                consensusStates: async (clientId, paginationKey)=>clientQueryService.ConsensusStates({
                        clientId: clientId,
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allConsensusStates: async (clientId)=>{
                    const consensusStates = [];
                    let response;
                    let key;
                    do {
                        response = await clientQueryService.ConsensusStates({
                            clientId: clientId,
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        consensusStates.push(...response.consensusStates);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_3.QueryConsensusStatesResponse.fromPartial({
                        consensusStates: consensusStates
                    });
                },
                params: async ()=>clientQueryService.ClientParams({}),
                stateTm: async (clientId)=>{
                    const response = await clientQueryService.ClientState({
                        clientId
                    });
                    return decodeTendermintClientStateAny(response.clientState);
                },
                statesTm: async (paginationKey)=>{
                    const { clientStates } = await clientQueryService.ClientStates({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    });
                    return clientStates.map(({ clientState })=>decodeTendermintClientStateAny(clientState));
                },
                allStatesTm: async ()=>{
                    const clientStates = [];
                    let response;
                    let key;
                    do {
                        response = await clientQueryService.ClientStates({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        clientStates.push(...response.clientStates);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return clientStates.map(({ clientState })=>decodeTendermintClientStateAny(clientState));
                },
                consensusStateTm: async (clientId, consensusHeight)=>{
                    const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                        clientId: clientId,
                        revisionHeight: consensusHeight?.revisionHeight,
                        revisionNumber: consensusHeight?.revisionNumber,
                        latestHeight: consensusHeight === undefined
                    }));
                    return decodeTendermintConsensusStateAny(response.consensusState);
                }
            },
            connection: {
                connection: async (connectionId)=>connectionQueryService.Connection({
                        connectionId: connectionId
                    }),
                connections: async (paginationKey)=>connectionQueryService.Connections({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allConnections: async ()=>{
                    const connections = [];
                    let response;
                    let key;
                    do {
                        response = await connectionQueryService.Connections({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        connections.push(...response.connections);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_4.QueryConnectionsResponse.fromPartial({
                        connections: connections,
                        height: response.height
                    });
                },
                clientConnections: async (clientId)=>connectionQueryService.ClientConnections({
                        clientId: clientId
                    }),
                clientState: async (connectionId)=>connectionQueryService.ConnectionClientState({
                        connectionId: connectionId
                    }),
                consensusState: async (connectionId, revisionHeight)=>connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
                        connectionId: connectionId,
                        revisionHeight: BigInt(revisionHeight)
                    }))
            },
            transfer: {
                denomTrace: async (hash)=>transferQueryService.DenomTrace({
                        hash: hash
                    }),
                denomTraces: async (paginationKey)=>transferQueryService.DenomTraces({
                        pagination: (0, queryclient_1.createPagination)(paginationKey)
                    }),
                allDenomTraces: async ()=>{
                    const denomTraces = [];
                    let response;
                    let key;
                    do {
                        response = await transferQueryService.DenomTraces({
                            pagination: (0, queryclient_1.createPagination)(key)
                        });
                        denomTraces.push(...response.denomTraces);
                        key = response.pagination?.nextKey;
                    }while (key && key.length)
                    return query_1.QueryDenomTracesResponse.fromPartial({
                        denomTraces: denomTraces
                    });
                },
                params: async ()=>transferQueryService.Params({})
            },
            verified: {
                channel: {
                    channel: async (portId, channelId)=>{
                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L55-L65
                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L117-L120
                        const key = (0, encoding_1.toAscii)(`channelEnds/ports/${portId}/channels/${channelId}`);
                        const { value } = await base.queryStoreVerified("ibc", key);
                        return value.length ? channel_1.Channel.decode(value) : null;
                    },
                    packetCommitment: async (portId, channelId, sequence)=>{
                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L128-L133
                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L183-L185
                        const key = (0, encoding_1.toAscii)(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);
                        const { value } = await base.queryStoreVerified("ibc", key);
                        // keeper code doesn't parse, but returns raw
                        return value;
                    },
                    packetAcknowledgement: async (portId, channelId, sequence)=>{
                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L159-L166
                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L153-L156
                        const key = (0, encoding_1.toAscii)(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);
                        const { value } = await base.queryStoreVerified("ibc", key);
                        // keeper code doesn't parse, but returns raw
                        return value;
                    },
                    nextSequenceReceive: async (portId, channelId)=>{
                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L92-L101
                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L133-L136
                        const key = (0, encoding_1.toAscii)(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);
                        const { value } = await base.queryStoreVerified("ibc", key);
                        return value.length ? math_1.Uint64.fromBytes(value).toNumber() : null;
                    }
                }
            }
        }
    };
}
exports.setupIbcExtension = setupIbcExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/mint/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupMintExtension = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupMintExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        mint: {
            params: async ()=>{
                const { params } = await queryService.Params({});
                (0, utils_1.assert)(params);
                return {
                    blocksPerYear: params.blocksPerYear,
                    goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
                    inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
                    inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
                    inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
                    mintDenom: params.mintDenom
                };
            },
            inflation: async ()=>{
                const { inflation } = await queryService.Inflation({});
                return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
            },
            annualProvisions: async ()=>{
                const { annualProvisions } = await queryService.AnnualProvisions({});
                return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
            }
        }
    };
}
exports.setupMintExtension = setupMintExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSlashingAminoConverters = exports.isAminoMsgUnjail = void 0;
function isAminoMsgUnjail(msg) {
    return msg.type === "cosmos-sdk/MsgUnjail";
}
exports.isAminoMsgUnjail = isAminoMsgUnjail;
function createSlashingAminoConverters() {
    throw new Error("Not implemented");
}
exports.createSlashingAminoConverters = createSlashingAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupSlashingExtension = void 0;
const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupSlashingExtension(base) {
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        slashing: {
            signingInfo: async (consAddress)=>{
                const response = await queryService.SigningInfo({
                    consAddress: consAddress
                });
                return response;
            },
            signingInfos: async (paginationKey)=>{
                const response = await queryService.SigningInfos({
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            params: async ()=>{
                const response = await queryService.Params({});
                return response;
            }
        }
    };
}
exports.setupSlashingExtension = setupSlashingExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createStakingAminoConverters = exports.isAminoMsgCancelUnbondingDelegation = exports.isAminoMsgUndelegate = exports.isAminoMsgBeginRedelegate = exports.isAminoMsgDelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgCreateValidator = exports.protoDecimalToJson = void 0;
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
function protoDecimalToJson(decimal) {
    const parsed = math_1.Decimal.fromAtomics(decimal, 18);
    const [whole, fractional] = parsed.toString().split(".");
    return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
}
exports.protoDecimalToJson = protoDecimalToJson;
function jsonDecimalToProto(decimal) {
    const parsed = math_1.Decimal.fromUserInput(decimal, 18);
    return parsed.atomics;
}
function isAminoMsgCreateValidator(msg) {
    return msg.type === "cosmos-sdk/MsgCreateValidator";
}
exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
function isAminoMsgEditValidator(msg) {
    return msg.type === "cosmos-sdk/MsgEditValidator";
}
exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
function isAminoMsgDelegate(msg) {
    return msg.type === "cosmos-sdk/MsgDelegate";
}
exports.isAminoMsgDelegate = isAminoMsgDelegate;
function isAminoMsgBeginRedelegate(msg) {
    return msg.type === "cosmos-sdk/MsgBeginRedelegate";
}
exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
function isAminoMsgUndelegate(msg) {
    return msg.type === "cosmos-sdk/MsgUndelegate";
}
exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
function isAminoMsgCancelUnbondingDelegation(msg) {
    return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
}
exports.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
function createStakingAminoConverters() {
    return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
            aminoType: "cosmos-sdk/MsgBeginRedelegate",
            toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_src_address: validatorSrcAddress,
                    validator_dst_address: validatorDstAddress,
                    amount: amount
                };
            },
            fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount })=>({
                    delegatorAddress: delegator_address,
                    validatorSrcAddress: validator_src_address,
                    validatorDstAddress: validator_dst_address,
                    amount: amount
                })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
            aminoType: "cosmos-sdk/MsgCreateValidator",
            toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value })=>{
                (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
                (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
                (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
                (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        security_contact: description.securityContact,
                        details: description.details
                    },
                    commission: {
                        rate: protoDecimalToJson(commission.rate),
                        max_rate: protoDecimalToJson(commission.maxRate),
                        max_change_rate: protoDecimalToJson(commission.maxChangeRate)
                    },
                    min_self_delegation: minSelfDelegation,
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
                    value: value
                };
            },
            fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value })=>{
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        securityContact: description.security_contact,
                        details: description.details
                    },
                    commission: {
                        rate: jsonDecimalToProto(commission.rate),
                        maxRate: jsonDecimalToProto(commission.max_rate),
                        maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
                    },
                    minSelfDelegation: min_self_delegation,
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
                    value: value
                };
            }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
            aminoType: "cosmos-sdk/MsgDelegate",
            toAmino: ({ delegatorAddress, validatorAddress, amount })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    amount: amount
                })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
            aminoType: "cosmos-sdk/MsgEditValidator",
            toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress })=>{
                (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        security_contact: description.securityContact,
                        details: description.details
                    },
                    // empty string in the protobuf document means "do not change"
                    commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : undefined,
                    // empty string in the protobuf document means "do not change"
                    min_self_delegation: minSelfDelegation ? minSelfDelegation : undefined,
                    validator_address: validatorAddress
                };
            },
            fromAmino: ({ description, commission_rate, min_self_delegation, validator_address })=>({
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        securityContact: description.security_contact,
                        details: description.details
                    },
                    // empty string in the protobuf document means "do not change"
                    commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
                    // empty string in the protobuf document means "do not change"
                    minSelfDelegation: min_self_delegation ?? "",
                    validatorAddress: validator_address
                })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
            aminoType: "cosmos-sdk/MsgUndelegate",
            toAmino: ({ delegatorAddress, validatorAddress, amount })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    amount: amount
                })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
            aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
            toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight })=>{
                (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount,
                    creation_height: creationHeight.toString()
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount, creation_height })=>({
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    amount: amount,
                    creationHeight: BigInt(creation_height)
                })
        }
    };
}
exports.createStakingAminoConverters = createStakingAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/staking/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.stakingTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js [client] (ecmascript)");
exports.stakingTypes = [
    [
        "/cosmos.staking.v1beta1.MsgBeginRedelegate",
        tx_1.MsgBeginRedelegate
    ],
    [
        "/cosmos.staking.v1beta1.MsgCreateValidator",
        tx_1.MsgCreateValidator
    ],
    [
        "/cosmos.staking.v1beta1.MsgDelegate",
        tx_1.MsgDelegate
    ],
    [
        "/cosmos.staking.v1beta1.MsgEditValidator",
        tx_1.MsgEditValidator
    ],
    [
        "/cosmos.staking.v1beta1.MsgUndelegate",
        tx_1.MsgUndelegate
    ],
    [
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
        tx_1.MsgCancelUnbondingDelegation
    ]
];
function isMsgBeginRedelegateEncodeObject(o) {
    return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}
exports.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
function isMsgCreateValidatorEncodeObject(o) {
    return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
}
exports.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
function isMsgDelegateEncodeObject(object) {
    return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
}
exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
function isMsgEditValidatorEncodeObject(o) {
    return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
}
exports.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
function isMsgUndelegateEncodeObject(object) {
    return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
}
exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
function isMsgCancelUnbondingDelegationEncodeObject(object) {
    return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
}
exports.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/staking/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupStakingExtension = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const query_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupStakingExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new query_1.QueryClientImpl(rpc);
    return {
        staking: {
            delegation: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.Delegation({
                    delegatorAddr: delegatorAddress,
                    validatorAddr: validatorAddress
                });
                return response;
            },
            delegatorDelegations: async (delegatorAddress, paginationKey)=>{
                const response = await queryService.DelegatorDelegations({
                    delegatorAddr: delegatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            delegatorUnbondingDelegations: async (delegatorAddress, paginationKey)=>{
                const response = await queryService.DelegatorUnbondingDelegations({
                    delegatorAddr: delegatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            delegatorValidator: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.DelegatorValidator({
                    delegatorAddr: delegatorAddress,
                    validatorAddr: validatorAddress
                });
                return response;
            },
            delegatorValidators: async (delegatorAddress, paginationKey)=>{
                const response = await queryService.DelegatorValidators({
                    delegatorAddr: delegatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            historicalInfo: async (height)=>{
                const response = await queryService.HistoricalInfo({
                    height: BigInt(height)
                });
                return response;
            },
            params: async ()=>{
                const response = await queryService.Params({});
                return response;
            },
            pool: async ()=>{
                const response = await queryService.Pool({});
                return response;
            },
            redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey)=>{
                const response = await queryService.Redelegations({
                    delegatorAddr: delegatorAddress,
                    srcValidatorAddr: sourceValidatorAddress,
                    dstValidatorAddr: destinationValidatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            unbondingDelegation: async (delegatorAddress, validatorAddress)=>{
                const response = await queryService.UnbondingDelegation({
                    delegatorAddr: delegatorAddress,
                    validatorAddr: validatorAddress
                });
                return response;
            },
            validator: async (validatorAddress)=>{
                const response = await queryService.Validator({
                    validatorAddr: validatorAddress
                });
                return response;
            },
            validatorDelegations: async (validatorAddress, paginationKey)=>{
                const response = await queryService.ValidatorDelegations({
                    validatorAddr: validatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            validators: async (status, paginationKey)=>{
                const response = await queryService.Validators({
                    status: status,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            },
            validatorUnbondingDelegations: async (validatorAddress, paginationKey)=>{
                const response = await queryService.ValidatorUnbondingDelegations({
                    validatorAddr: validatorAddress,
                    pagination: (0, queryclient_1.createPagination)(paginationKey)
                });
                return response;
            }
        }
    };
}
exports.setupStakingExtension = setupStakingExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/tx/queries.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupTxExtension = void 0;
const proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
const signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js [client] (ecmascript)");
const service_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js [client] (ecmascript)");
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
function setupTxExtension(base) {
    // Use this service to get easy typed access to query methods
    // This cannot be used for proof verification
    const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
    const queryService = new service_1.ServiceClientImpl(rpc);
    return {
        tx: {
            getTx: async (txId)=>{
                const request = {
                    hash: txId
                };
                const response = await queryService.GetTx(request);
                return response;
            },
            simulate: async (messages, memo, signer, sequence)=>{
                const tx = tx_1.Tx.fromPartial({
                    authInfo: tx_1.AuthInfo.fromPartial({
                        fee: tx_1.Fee.fromPartial({}),
                        signerInfos: [
                            {
                                publicKey: (0, proto_signing_1.encodePubkey)(signer),
                                sequence: BigInt(sequence),
                                modeInfo: {
                                    single: {
                                        mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED
                                    }
                                }
                            }
                        ]
                    }),
                    body: tx_1.TxBody.fromPartial({
                        messages: Array.from(messages),
                        memo: memo
                    }),
                    signatures: [
                        new Uint8Array()
                    ]
                });
                const request = service_1.SimulateRequest.fromPartial({
                    txBytes: tx_1.Tx.encode(tx).finish()
                });
                const response = await queryService.Simulate(request);
                return response;
            }
        }
    };
}
exports.setupTxExtension = setupTxExtension; //# sourceMappingURL=queries.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createVestingAminoConverters = exports.isAminoMsgCreateVestingAccount = void 0;
function isAminoMsgCreateVestingAccount(msg) {
    return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
}
exports.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
function createVestingAminoConverters() {
    return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
            aminoType: "cosmos-sdk/MsgCreateVestingAccount",
            toAmino: ({ fromAddress, toAddress, amount, endTime, delayed })=>({
                    from_address: fromAddress,
                    to_address: toAddress,
                    amount: [
                        ...amount
                    ],
                    end_time: endTime.toString(),
                    delayed: delayed
                }),
            fromAmino: ({ from_address, to_address, amount, end_time, delayed })=>({
                    fromAddress: from_address,
                    toAddress: to_address,
                    amount: [
                        ...amount
                    ],
                    endTime: BigInt(end_time),
                    delayed: delayed
                })
        }
    };
}
exports.createVestingAminoConverters = createVestingAminoConverters; //# sourceMappingURL=aminomessages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.vestingTypes = void 0;
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js [client] (ecmascript)");
exports.vestingTypes = [
    [
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
        tx_1.MsgCreateVestingAccount
    ]
]; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/modules/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createStakingAminoConverters = exports.setupSlashingExtension = exports.isAminoMsgUnjail = exports.createSlashingAminoConverters = exports.setupMintExtension = exports.setupIbcExtension = exports.isMsgTransferEncodeObject = exports.ibcTypes = exports.isAminoMsgTransfer = exports.createIbcAminoConverters = exports.groupTypes = exports.createGroupAminoConverters = exports.setupGovExtension = exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgDeposit = exports.createGovAminoConverters = exports.setupFeegrantExtension = exports.feegrantTypes = exports.createFeegrantAminoConverters = exports.isAminoMsgSubmitEvidence = exports.createEvidenceAminoConverters = exports.setupDistributionExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgFundCommunityPool = exports.createDistributionAminoConverters = exports.isAminoMsgVerifyInvariant = exports.createCrysisAminoConverters = exports.setupBankExtension = exports.isMsgSendEncodeObject = exports.bankTypes = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.createBankAminoConverters = exports.setupAuthzExtension = exports.authzTypes = exports.createAuthzAminoConverters = exports.setupAuthExtension = void 0;
exports.vestingTypes = exports.isAminoMsgCreateVestingAccount = exports.createVestingAminoConverters = exports.setupTxExtension = exports.setupStakingExtension = exports.stakingTypes = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgUndelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgDelegate = void 0;
var queries_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/auth/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupAuthExtension", {
    enumerable: true,
    get: function() {
        return queries_1.setupAuthExtension;
    }
});
var aminomessages_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createAuthzAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_1.createAuthzAminoConverters;
    }
});
var messages_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/authz/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "authzTypes", {
    enumerable: true,
    get: function() {
        return messages_1.authzTypes;
    }
});
var queries_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/authz/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupAuthzExtension", {
    enumerable: true,
    get: function() {
        return queries_2.setupAuthzExtension;
    }
});
var aminomessages_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createBankAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_2.createBankAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgMultiSend", {
    enumerable: true,
    get: function() {
        return aminomessages_2.isAminoMsgMultiSend;
    }
});
Object.defineProperty(exports, "isAminoMsgSend", {
    enumerable: true,
    get: function() {
        return aminomessages_2.isAminoMsgSend;
    }
});
var messages_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/bank/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "bankTypes", {
    enumerable: true,
    get: function() {
        return messages_2.bankTypes;
    }
});
Object.defineProperty(exports, "isMsgSendEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_2.isMsgSendEncodeObject;
    }
});
var queries_3 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/bank/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupBankExtension", {
    enumerable: true,
    get: function() {
        return queries_3.setupBankExtension;
    }
});
var aminomessages_3 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createCrysisAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_3.createCrysisAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgVerifyInvariant", {
    enumerable: true,
    get: function() {
        return aminomessages_3.isAminoMsgVerifyInvariant;
    }
});
var aminomessages_4 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createDistributionAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_4.createDistributionAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgFundCommunityPool", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgFundCommunityPool;
    }
});
Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgSetWithdrawAddress;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", {
    enumerable: true,
    get: function() {
        return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    }
});
var messages_3 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "distributionTypes", {
    enumerable: true,
    get: function() {
        return messages_3.distributionTypes;
    }
});
Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    }
});
var queries_4 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupDistributionExtension", {
    enumerable: true,
    get: function() {
        return queries_4.setupDistributionExtension;
    }
});
var aminomessages_5 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createEvidenceAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_5.createEvidenceAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitEvidence", {
    enumerable: true,
    get: function() {
        return aminomessages_5.isAminoMsgSubmitEvidence;
    }
});
var aminomessages_6 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createFeegrantAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_6.createFeegrantAminoConverters;
    }
});
var messages_4 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "feegrantTypes", {
    enumerable: true,
    get: function() {
        return messages_4.feegrantTypes;
    }
});
var queries_5 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupFeegrantExtension", {
    enumerable: true,
    get: function() {
        return queries_5.setupFeegrantExtension;
    }
});
var aminomessages_7 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createGovAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_7.createGovAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgDeposit", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgDeposit;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitProposal", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgSubmitProposal;
    }
});
Object.defineProperty(exports, "isAminoMsgVote", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgVote;
    }
});
Object.defineProperty(exports, "isAminoMsgVoteWeighted", {
    enumerable: true,
    get: function() {
        return aminomessages_7.isAminoMsgVoteWeighted;
    }
});
var messages_5 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/gov/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "govTypes", {
    enumerable: true,
    get: function() {
        return messages_5.govTypes;
    }
});
Object.defineProperty(exports, "isMsgDepositEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgDepositEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgSubmitProposalEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgVoteEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_5.isMsgVoteWeightedEncodeObject;
    }
});
var queries_6 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/gov/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupGovExtension", {
    enumerable: true,
    get: function() {
        return queries_6.setupGovExtension;
    }
});
var aminomessages_8 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createGroupAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_8.createGroupAminoConverters;
    }
});
var messages_6 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/group/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "groupTypes", {
    enumerable: true,
    get: function() {
        return messages_6.groupTypes;
    }
});
var aminomessages_9 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createIbcAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_9.createIbcAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgTransfer", {
    enumerable: true,
    get: function() {
        return aminomessages_9.isAminoMsgTransfer;
    }
});
var messages_7 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "ibcTypes", {
    enumerable: true,
    get: function() {
        return messages_7.ibcTypes;
    }
});
Object.defineProperty(exports, "isMsgTransferEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_7.isMsgTransferEncodeObject;
    }
});
var queries_7 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupIbcExtension", {
    enumerable: true,
    get: function() {
        return queries_7.setupIbcExtension;
    }
});
var queries_8 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/mint/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupMintExtension", {
    enumerable: true,
    get: function() {
        return queries_8.setupMintExtension;
    }
});
var aminomessages_10 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createSlashingAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_10.createSlashingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgUnjail", {
    enumerable: true,
    get: function() {
        return aminomessages_10.isAminoMsgUnjail;
    }
});
var queries_9 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupSlashingExtension", {
    enumerable: true,
    get: function() {
        return queries_9.setupSlashingExtension;
    }
});
var aminomessages_11 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createStakingAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_11.createStakingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgBeginRedelegate", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgBeginRedelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateValidator", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgCreateValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgDelegate", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgDelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgEditValidator", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgEditValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgUndelegate", {
    enumerable: true,
    get: function() {
        return aminomessages_11.isAminoMsgUndelegate;
    }
});
var messages_8 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/staking/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgBeginRedelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgCreateValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgDelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgDelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgEditValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgUndelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return messages_8.isMsgUndelegateEncodeObject;
    }
});
Object.defineProperty(exports, "stakingTypes", {
    enumerable: true,
    get: function() {
        return messages_8.stakingTypes;
    }
});
var queries_10 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/staking/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupStakingExtension", {
    enumerable: true,
    get: function() {
        return queries_10.setupStakingExtension;
    }
});
var queries_11 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/tx/queries.js [client] (ecmascript)");
Object.defineProperty(exports, "setupTxExtension", {
    enumerable: true,
    get: function() {
        return queries_11.setupTxExtension;
    }
});
var aminomessages_12 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js [client] (ecmascript)");
Object.defineProperty(exports, "createVestingAminoConverters", {
    enumerable: true,
    get: function() {
        return aminomessages_12.createVestingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", {
    enumerable: true,
    get: function() {
        return aminomessages_12.isAminoMsgCreateVestingAccount;
    }
});
var messages_9 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js [client] (ecmascript)");
Object.defineProperty(exports, "vestingTypes", {
    enumerable: true,
    get: function() {
        return messages_9.vestingTypes;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/multisignature.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.makeCompactBitArray = void 0;
const amino_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/amino/build/index.js [client] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
const multisig_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js [client] (ecmascript)");
const signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js [client] (ecmascript)");
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js [client] (ecmascript)");
const tx_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js [client] (ecmascript)");
function makeCompactBitArray(bits) {
    const byteCount = Math.ceil(bits.length / 8);
    const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
    const bytes = new Uint8Array(byteCount); // zero-filled
    bits.forEach((value, index)=>{
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        // eslint-disable-next-line no-bitwise
        if (value) bytes[bytePos] |= 0b1 << 8 - 1 - bitPos;
    });
    return multisig_1.CompactBitArray.fromPartial({
        elems: bytes,
        extraBitsStored: extraBits
    });
}
exports.makeCompactBitArray = makeCompactBitArray;
/**
 * Creates a signed transaction from signer info, transaction body and signatures.
 * The result can be broadcasted after serialization.
 *
 * Consider using `makeMultisignedTxBytes` instead if you want to broadcast the
 * transaction immediately.
 */ function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
    const addresses = Array.from(signatures.keys());
    const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
    const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
    const signaturesList = new Array();
    for(let i = 0; i < multisigPubkey.value.pubkeys.length; i++){
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
            signers[i] = true;
            signaturesList.push(signature);
        }
    }
    const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
            multi: {
                bitarray: makeCompactBitArray(signers),
                modeInfos: signaturesList.map((_)=>({
                        single: {
                            mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON
                        }
                    }))
            }
        },
        sequence: BigInt(sequence)
    };
    const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [
            signerInfo
        ],
        fee: {
            amount: [
                ...fee.amount
            ],
            gasLimit: BigInt(fee.gas)
        }
    });
    const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
    const signedTx = tx_2.TxRaw.fromPartial({
        bodyBytes: bodyBytes,
        authInfoBytes: authInfoBytes,
        signatures: [
            multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({
                signatures: signaturesList
            })).finish()
        ]
    });
    return signedTx;
}
exports.makeMultisignedTx = makeMultisignedTx;
/**
 * Creates a signed transaction from signer info, transaction body and signatures.
 * The result can be broadcasted.
 *
 * This is a wrapper around `makeMultisignedTx` that encodes the transaction for broadcasting.
 */ function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
    const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
    return Uint8Array.from(tx_2.TxRaw.encode(signedTx).finish());
}
exports.makeMultisignedTxBytes = makeMultisignedTxBytes; //# sourceMappingURL=multisignature.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/search.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSearchTxQueryArray = void 0;
function isSearchTxQueryArray(query) {
    return Array.isArray(query);
}
exports.isSearchTxQueryArray = isSearchTxQueryArray; //# sourceMappingURL=search.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/stargateclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StargateClient = exports.BroadcastTxError = exports.assertIsDeliverTxFailure = exports.assertIsDeliverTxSuccess = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.TimeoutError = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const amino_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/amino/build/index.js [client] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const tendermint_rpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const abci_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js [client] (ecmascript)");
const accounts_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/accounts.js [client] (ecmascript)");
const events_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/events.js [client] (ecmascript)");
const modules_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/index.js [client] (ecmascript)");
const queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
const search_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/search.js [client] (ecmascript)");
class TimeoutError extends Error {
    constructor(message, txId){
        super(message);
        this.txId = txId;
    }
}
exports.TimeoutError = TimeoutError;
function isDeliverTxFailure(result) {
    return !!result.code;
}
exports.isDeliverTxFailure = isDeliverTxFailure;
function isDeliverTxSuccess(result) {
    return !isDeliverTxFailure(result);
}
exports.isDeliverTxSuccess = isDeliverTxSuccess;
/**
 * Ensures the given result is a success. Throws a detailed error message otherwise.
 */ function assertIsDeliverTxSuccess(result) {
    if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
    }
}
exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
/**
 * Ensures the given result is a failure. Throws a detailed error message otherwise.
 */ function assertIsDeliverTxFailure(result) {
    if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
    }
}
exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
/**
 * An error when broadcasting the transaction. This contains the CheckTx errors
 * from the blockchain. Once a transaction is included in a block no BroadcastTxError
 * is thrown, even if the execution fails (DeliverTx errors).
 */ class BroadcastTxError extends Error {
    constructor(code, codespace, log){
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
    }
}
exports.BroadcastTxError = BroadcastTxError;
class StargateClient {
    /**
     * Creates an instance by connecting to the given CometBFT RPC endpoint.
     *
     * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
     * To set the Comet client explicitly, use `create`.
     */ static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return StargateClient.create(cometClient, options);
    }
    /**
     * Creates an instance from a manually created Comet client.
     * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
     */ static async create(cometClient, options = {}) {
        return new StargateClient(cometClient, options);
    }
    constructor(cometClient, options){
        if (cometClient) {
            this.cometClient = cometClient;
            this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
    }
    getCometClient() {
        return this.cometClient;
    }
    forceGetCometClient() {
        if (!this.cometClient) {
            throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
    }
    getQueryClient() {
        return this.queryClient;
    }
    forceGetQueryClient() {
        if (!this.queryClient) {
            throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
    }
    async getChainId() {
        if (!this.chainId) {
            const response = await this.forceGetCometClient().status();
            const chainId = response.nodeInfo.network;
            if (!chainId) throw new Error("Chain ID must not be empty");
            this.chainId = chainId;
        }
        return this.chainId;
    }
    async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
    }
    async getAccount(searchAddress) {
        try {
            const account = await this.forceGetQueryClient().auth.account(searchAddress);
            return account ? this.accountParser(account) : null;
        } catch (error) {
            if (/rpc error: code = NotFound/i.test(error.toString())) {
                return null;
            }
            throw error;
        }
    }
    async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
            throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
            accountNumber: account.accountNumber,
            sequence: account.sequence
        };
    }
    async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
            id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
            header: {
                version: {
                    block: new math_1.Uint53(response.block.header.version.block).toString(),
                    app: new math_1.Uint53(response.block.header.version.app).toString()
                },
                height: response.block.header.height,
                chainId: response.block.header.chainId,
                time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
            },
            txs: response.block.txs
        };
    }
    async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
    }
    /**
     * Queries all balances for all denoms that belong to this address.
     *
     * Uses the grpc queries (which iterates over the store internally), and we cannot get
     * proofs from such a method.
     */ async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
    }
    async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = undefined;
        do {
            const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
            const loadedDelegations = delegationResponses || [];
            allDelegations.push(...loadedDelegations);
            startAtKey = pagination?.nextKey;
        }while (startAtKey !== undefined && startAtKey.length !== 0)
        const sumValues = allDelegations.reduce((previousValue, currentValue)=>{
            // Safe because field is set to non-nullable (https://github.com/cosmos/cosmos-sdk/blob/v0.45.3/proto/cosmos/staking/v1beta1/staking.proto#L295)
            (0, utils_1.assert)(currentValue.balance);
            return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
    }
    async getDelegation(delegatorAddress, validatorAddress) {
        let delegatedAmount;
        try {
            delegatedAmount = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse?.balance;
        } catch (e) {
            if (e.toString().includes("key not found")) {
            // ignore, `delegatedAmount` remains undefined
            } else {
                throw e;
            }
        }
        return delegatedAmount || null;
    }
    async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
    }
    async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
            rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
            rawQuery = query.map((t)=>{
                // numeric values must not have quotes https://github.com/cosmos/cosmjs/issues/1462
                if (typeof t.value === "string") return `${t.key}='${t.value}'`;
                else return `${t.key}=${t.value}`;
            }).join(" AND ");
        } else {
            throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
    }
    disconnect() {
        if (this.cometClient) this.cometClient.disconnect();
    }
    /**
     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
     *
     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
     * an error is thrown.
     *
     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
     *
     * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
     * usually needs to check for execution success or failure.
     */ async broadcastTx(tx, timeoutMs = 60000, pollIntervalMs = 3000) {
        let timedOut = false;
        const txPollTimeout = setTimeout(()=>{
            timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId)=>{
            if (timedOut) {
                throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1000} seconds.`, txId);
            }
            await (0, utils_1.sleep)(pollIntervalMs);
            const result = await this.getTx(txId);
            return result ? {
                code: result.code,
                height: result.height,
                txIndex: result.txIndex,
                events: result.events,
                rawLog: result.rawLog,
                transactionHash: txId,
                msgResponses: result.msgResponses,
                gasUsed: result.gasUsed,
                gasWanted: result.gasWanted
            } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject)=>pollForTx(transactionId).then((value)=>{
                clearTimeout(txPollTimeout);
                resolve(value);
            }, (error)=>{
                clearTimeout(txPollTimeout);
                reject(error);
            }));
    }
    /**
     * Broadcasts a signed transaction to the network without monitoring it.
     *
     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
     * an error is thrown.
     *
     * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
     * usually needs to check if the transaction was included in a block and was successful.
     *
     * @returns Returns the hash of the transaction
     */ async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({
            tx
        });
        if (broadcasted.code) {
            return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
    }
    async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({
            query: query
        });
        return results.txs.map((tx)=>{
            const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
            return {
                height: tx.height,
                txIndex: tx.index,
                hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
                code: tx.result.code,
                events: tx.result.events.map(events_1.fromTendermintEvent),
                rawLog: tx.result.log || "",
                tx: tx.tx,
                msgResponses: txMsgData.msgResponses,
                gasUsed: tx.result.gasUsed,
                gasWanted: tx.result.gasWanted
            };
        });
    }
}
exports.StargateClient = StargateClient; //# sourceMappingURL=stargateclient.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/signingstargateclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SigningStargateClient = exports.createDefaultAminoConverters = exports.defaultRegistryTypes = void 0;
const amino_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/amino/build/index.js [client] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
const tendermint_rpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const coin_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js [client] (ecmascript)");
const tx_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js [client] (ecmascript)");
const tx_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js [client] (ecmascript)");
const signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js [client] (ecmascript)");
const tx_3 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js [client] (ecmascript)");
const tx_4 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js [client] (ecmascript)");
const aminotypes_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/aminotypes.js [client] (ecmascript)");
const fee_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/fee.js [client] (ecmascript)");
const modules_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/index.js [client] (ecmascript)");
const modules_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/index.js [client] (ecmascript)");
const stargateclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/stargateclient.js [client] (ecmascript)");
exports.defaultRegistryTypes = [
    [
        "/cosmos.base.v1beta1.Coin",
        coin_1.Coin
    ],
    ...modules_1.authzTypes,
    ...modules_1.bankTypes,
    ...modules_1.distributionTypes,
    ...modules_1.feegrantTypes,
    ...modules_1.govTypes,
    ...modules_1.groupTypes,
    ...modules_1.stakingTypes,
    ...modules_1.ibcTypes,
    ...modules_1.vestingTypes
];
function createDefaultAminoConverters() {
    return {
        ...(0, modules_2.createAuthzAminoConverters)(),
        ...(0, modules_2.createBankAminoConverters)(),
        ...(0, modules_2.createDistributionAminoConverters)(),
        ...(0, modules_2.createGovAminoConverters)(),
        ...(0, modules_2.createStakingAminoConverters)(),
        ...(0, modules_2.createIbcAminoConverters)(),
        ...(0, modules_2.createFeegrantAminoConverters)(),
        ...(0, modules_2.createVestingAminoConverters)()
    };
}
exports.createDefaultAminoConverters = createDefaultAminoConverters;
class SigningStargateClient extends stargateclient_1.StargateClient {
    /**
     * Creates an instance by connecting to the given CometBFT RPC endpoint.
     *
     * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
     * To set the Comet client explicitly, use `createWithSigner`.
     */ static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return SigningStargateClient.createWithSigner(cometClient, signer, options);
    }
    /**
     * Creates an instance from a manually created Comet client.
     * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
     */ static async createWithSigner(cometClient, signer, options = {}) {
        return new SigningStargateClient(cometClient, signer, options);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */ static async offline(signer, options = {}) {
        return new SigningStargateClient(undefined, signer, options);
    }
    constructor(cometClient, signer, options){
        super(cometClient, options);
        // Starting with Cosmos SDK 0.47, we see many cases in which 1.3 is not enough anymore
        // E.g. https://github.com/cosmos/cosmos-sdk/issues/16020
        this.defaultGasMultiplier = 1.4;
        const { registry = new proto_signing_1.Registry(exports.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
    }
    async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m)=>this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account)=>account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
    }
    async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
            typeUrl: "/cosmos.bank.v1beta1.MsgSend",
            value: {
                fromAddress: senderAddress,
                toAddress: recipientAddress,
                amount: [
                    ...amount
                ]
            }
        };
        return this.signAndBroadcast(senderAddress, [
            sendMsg
        ], fee, memo);
    }
    async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
            typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
            value: tx_2.MsgDelegate.fromPartial({
                delegatorAddress: delegatorAddress,
                validatorAddress: validatorAddress,
                amount: amount
            })
        };
        return this.signAndBroadcast(delegatorAddress, [
            delegateMsg
        ], fee, memo);
    }
    async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
            typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
            value: tx_2.MsgUndelegate.fromPartial({
                delegatorAddress: delegatorAddress,
                validatorAddress: validatorAddress,
                amount: amount
            })
        };
        return this.signAndBroadcast(delegatorAddress, [
            undelegateMsg
        ], fee, memo);
    }
    async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
            typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
            value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
                delegatorAddress: delegatorAddress,
                validatorAddress: validatorAddress
            })
        };
        return this.signAndBroadcast(delegatorAddress, [
            withdrawMsg
        ], fee, memo);
    }
    /**
     * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
     * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
     * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
     * @see https://github.com/cosmos/cosmjs/issues/1493
     */ async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, /** timeout in seconds */ timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1000000000) : undefined;
        const transferMsg = {
            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
            value: tx_4.MsgTransfer.fromPartial({
                sourcePort: sourcePort,
                sourceChannel: sourceChannel,
                sender: senderAddress,
                receiver: recipientAddress,
                token: transferAmount,
                timeoutHeight: timeoutHeight,
                timeoutTimestamp: timeoutTimestampNanoseconds
            })
        };
        return this.signAndBroadcast(senderAddress, [
            transferMsg
        ], fee, memo);
    }
    async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
            (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
            const gasEstimation = await this.simulate(signerAddress, messages, memo);
            const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
            usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
            usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, undefined, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    /**
     * This method is useful if you want to send a transaction in broadcast,
     * without waiting for it to be placed inside a block, because for example
     * I would like to receive the hash to later track the transaction with another tool.
     * @returns Returns the hash of the transaction
     */ async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
            (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
            const gasEstimation = await this.simulate(signerAddress, messages, memo);
            const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
            usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
            usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, undefined, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */ async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
            signerData = explicitSignerData;
        } else {
            const { accountNumber, sequence } = await this.getSequence(signerAddress);
            const chainId = await this.getChainId();
            signerData = {
                accountNumber: accountNumber,
                sequence: sequence,
                chainId: chainId
            };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
    }
    async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account)=>account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg)=>this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
            messages: signed.msgs.map((msg)=>this.aminoTypes.fromAmino(msg)),
            memo: signed.memo,
            timeoutHeight: timeoutHeight
        };
        const signedTxBodyEncodeObject = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([
            {
                pubkey,
                sequence: signedSequence
            }
        ], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
            bodyBytes: signedTxBodyBytes,
            authInfoBytes: signedAuthInfoBytes,
            signatures: [
                (0, encoding_1.fromBase64)(signature.signature)
            ]
        });
    }
    async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account)=>account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: {
                messages: messages,
                memo: memo,
                timeoutHeight: timeoutHeight
            }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([
            {
                pubkey,
                sequence
            }
        ], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
            bodyBytes: signed.bodyBytes,
            authInfoBytes: signed.authInfoBytes,
            signatures: [
                (0, encoding_1.fromBase64)(signature.signature)
            ]
        });
    }
}
exports.SigningStargateClient = SigningStargateClient; //# sourceMappingURL=signingstargateclient.js.map
}),
"[project]/node_modules/@cosmjs/stargate/build/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgTransfer = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateVestingAccount = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createVestingAminoConverters = exports.createStakingAminoConverters = exports.createSlashingAminoConverters = exports.createIbcAminoConverters = exports.createGroupAminoConverters = exports.createGovAminoConverters = exports.createFeegrantAminoConverters = exports.createEvidenceAminoConverters = exports.createDistributionAminoConverters = exports.createCrysisAminoConverters = exports.createBankAminoConverters = exports.createAuthzAminoConverters = exports.logs = exports.GasPrice = exports.calculateFee = exports.fromTendermintEvent = exports.AminoTypes = exports.accountFromAny = void 0;
exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.BroadcastTxError = exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.createDefaultAminoConverters = exports.isSearchTxQueryArray = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.setupTxExtension = exports.setupStakingExtension = exports.setupSlashingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupFeegrantExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthzExtension = exports.setupAuthExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
var accounts_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/accounts.js [client] (ecmascript)");
Object.defineProperty(exports, "accountFromAny", {
    enumerable: true,
    get: function() {
        return accounts_1.accountFromAny;
    }
});
var aminotypes_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/aminotypes.js [client] (ecmascript)");
Object.defineProperty(exports, "AminoTypes", {
    enumerable: true,
    get: function() {
        return aminotypes_1.AminoTypes;
    }
});
var events_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/events.js [client] (ecmascript)");
Object.defineProperty(exports, "fromTendermintEvent", {
    enumerable: true,
    get: function() {
        return events_1.fromTendermintEvent;
    }
});
var fee_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/fee.js [client] (ecmascript)");
Object.defineProperty(exports, "calculateFee", {
    enumerable: true,
    get: function() {
        return fee_1.calculateFee;
    }
});
Object.defineProperty(exports, "GasPrice", {
    enumerable: true,
    get: function() {
        return fee_1.GasPrice;
    }
});
exports.logs = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/logs.js [client] (ecmascript)"));
var modules_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/modules/index.js [client] (ecmascript)");
Object.defineProperty(exports, "createAuthzAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createAuthzAminoConverters;
    }
});
Object.defineProperty(exports, "createBankAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createBankAminoConverters;
    }
});
Object.defineProperty(exports, "createCrysisAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createCrysisAminoConverters;
    }
});
Object.defineProperty(exports, "createDistributionAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createDistributionAminoConverters;
    }
});
Object.defineProperty(exports, "createEvidenceAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createEvidenceAminoConverters;
    }
});
Object.defineProperty(exports, "createFeegrantAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createFeegrantAminoConverters;
    }
});
Object.defineProperty(exports, "createGovAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createGovAminoConverters;
    }
});
Object.defineProperty(exports, "createGroupAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createGroupAminoConverters;
    }
});
Object.defineProperty(exports, "createIbcAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createIbcAminoConverters;
    }
});
Object.defineProperty(exports, "createSlashingAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createSlashingAminoConverters;
    }
});
Object.defineProperty(exports, "createStakingAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createStakingAminoConverters;
    }
});
Object.defineProperty(exports, "createVestingAminoConverters", {
    enumerable: true,
    get: function() {
        return modules_1.createVestingAminoConverters;
    }
});
Object.defineProperty(exports, "isAminoMsgBeginRedelegate", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgBeginRedelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateValidator", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgCreateValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgCreateVestingAccount;
    }
});
Object.defineProperty(exports, "isAminoMsgDelegate", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgDelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgDeposit", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgDeposit;
    }
});
Object.defineProperty(exports, "isAminoMsgEditValidator", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgEditValidator;
    }
});
Object.defineProperty(exports, "isAminoMsgFundCommunityPool", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgFundCommunityPool;
    }
});
Object.defineProperty(exports, "isAminoMsgMultiSend", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgMultiSend;
    }
});
Object.defineProperty(exports, "isAminoMsgSend", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSend;
    }
});
Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSetWithdrawAddress;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitEvidence", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSubmitEvidence;
    }
});
Object.defineProperty(exports, "isAminoMsgSubmitProposal", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgSubmitProposal;
    }
});
Object.defineProperty(exports, "isAminoMsgTransfer", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgTransfer;
    }
});
Object.defineProperty(exports, "isAminoMsgUndelegate", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgUndelegate;
    }
});
Object.defineProperty(exports, "isAminoMsgUnjail", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgUnjail;
    }
});
Object.defineProperty(exports, "isAminoMsgVerifyInvariant", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgVerifyInvariant;
    }
});
Object.defineProperty(exports, "isAminoMsgVote", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgVote;
    }
});
Object.defineProperty(exports, "isAminoMsgVoteWeighted", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgVoteWeighted;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgWithdrawDelegatorReward;
    }
});
Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", {
    enumerable: true,
    get: function() {
        return modules_1.isAminoMsgWithdrawValidatorCommission;
    }
});
Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgBeginRedelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgCreateValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgDelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgDelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgDepositEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgDepositEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgEditValidatorEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgSendEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgSendEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgSubmitProposalEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgTransferEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgTransferEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgUndelegateEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgUndelegateEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgVoteEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgVoteWeightedEncodeObject;
    }
});
Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", {
    enumerable: true,
    get: function() {
        return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    }
});
Object.defineProperty(exports, "setupAuthExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupAuthExtension;
    }
});
Object.defineProperty(exports, "setupAuthzExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupAuthzExtension;
    }
});
Object.defineProperty(exports, "setupBankExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupBankExtension;
    }
});
Object.defineProperty(exports, "setupDistributionExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupDistributionExtension;
    }
});
Object.defineProperty(exports, "setupFeegrantExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupFeegrantExtension;
    }
});
Object.defineProperty(exports, "setupGovExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupGovExtension;
    }
});
Object.defineProperty(exports, "setupIbcExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupIbcExtension;
    }
});
Object.defineProperty(exports, "setupMintExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupMintExtension;
    }
});
Object.defineProperty(exports, "setupSlashingExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupSlashingExtension;
    }
});
Object.defineProperty(exports, "setupStakingExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupStakingExtension;
    }
});
Object.defineProperty(exports, "setupTxExtension", {
    enumerable: true,
    get: function() {
        return modules_1.setupTxExtension;
    }
});
var multisignature_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/multisignature.js [client] (ecmascript)");
Object.defineProperty(exports, "makeMultisignedTx", {
    enumerable: true,
    get: function() {
        return multisignature_1.makeMultisignedTx;
    }
});
Object.defineProperty(exports, "makeMultisignedTxBytes", {
    enumerable: true,
    get: function() {
        return multisignature_1.makeMultisignedTxBytes;
    }
});
var queryclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/queryclient/index.js [client] (ecmascript)");
Object.defineProperty(exports, "createPagination", {
    enumerable: true,
    get: function() {
        return queryclient_1.createPagination;
    }
});
Object.defineProperty(exports, "createProtobufRpcClient", {
    enumerable: true,
    get: function() {
        return queryclient_1.createProtobufRpcClient;
    }
});
Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", {
    enumerable: true,
    get: function() {
        return queryclient_1.decodeCosmosSdkDecFromProto;
    }
});
Object.defineProperty(exports, "QueryClient", {
    enumerable: true,
    get: function() {
        return queryclient_1.QueryClient;
    }
});
var search_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/search.js [client] (ecmascript)");
Object.defineProperty(exports, "isSearchTxQueryArray", {
    enumerable: true,
    get: function() {
        return search_1.isSearchTxQueryArray;
    }
});
var signingstargateclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/signingstargateclient.js [client] (ecmascript)");
Object.defineProperty(exports, "createDefaultAminoConverters", {
    enumerable: true,
    get: function() {
        return signingstargateclient_1.createDefaultAminoConverters;
    }
});
Object.defineProperty(exports, "defaultRegistryTypes", {
    enumerable: true,
    get: function() {
        return signingstargateclient_1.defaultRegistryTypes;
    }
});
Object.defineProperty(exports, "SigningStargateClient", {
    enumerable: true,
    get: function() {
        return signingstargateclient_1.SigningStargateClient;
    }
});
var stargateclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stargate/build/stargateclient.js [client] (ecmascript)");
Object.defineProperty(exports, "assertIsDeliverTxFailure", {
    enumerable: true,
    get: function() {
        return stargateclient_1.assertIsDeliverTxFailure;
    }
});
Object.defineProperty(exports, "assertIsDeliverTxSuccess", {
    enumerable: true,
    get: function() {
        return stargateclient_1.assertIsDeliverTxSuccess;
    }
});
Object.defineProperty(exports, "BroadcastTxError", {
    enumerable: true,
    get: function() {
        return stargateclient_1.BroadcastTxError;
    }
});
Object.defineProperty(exports, "isDeliverTxFailure", {
    enumerable: true,
    get: function() {
        return stargateclient_1.isDeliverTxFailure;
    }
});
Object.defineProperty(exports, "isDeliverTxSuccess", {
    enumerable: true,
    get: function() {
        return stargateclient_1.isDeliverTxSuccess;
    }
});
Object.defineProperty(exports, "StargateClient", {
    enumerable: true,
    get: function() {
        return stargateclient_1.StargateClient;
    }
});
Object.defineProperty(exports, "TimeoutError", {
    enumerable: true,
    get: function() {
        return stargateclient_1.TimeoutError;
    }
});
var proto_signing_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/proto-signing/build/index.js [client] (ecmascript)");
Object.defineProperty(exports, "coin", {
    enumerable: true,
    get: function() {
        return proto_signing_1.coin;
    }
});
Object.defineProperty(exports, "coins", {
    enumerable: true,
    get: function() {
        return proto_signing_1.coins;
    }
});
Object.defineProperty(exports, "makeCosmoshubPath", {
    enumerable: true,
    get: function() {
        return proto_signing_1.makeCosmoshubPath;
    }
});
Object.defineProperty(exports, "parseCoins", {
    enumerable: true,
    get: function() {
        return proto_signing_1.parseCoins;
    }
}); //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40cosmjs_stargate_build_89b76028._.js.map