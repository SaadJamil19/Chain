{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/build/generated/codecimpl.js"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = (function() {\n\n    /**\n     * Namespace ics23.\n     * @exports ics23\n     * @namespace\n     */\n    var ics23 = {};\n\n    /**\n     * HashOp enum.\n     * @name ics23.HashOp\n     * @enum {string}\n     * @property {number} NO_HASH=0 NO_HASH value\n     * @property {number} SHA256=1 SHA256 value\n     * @property {number} SHA512=2 SHA512 value\n     * @property {number} KECCAK=3 KECCAK value\n     * @property {number} RIPEMD160=4 RIPEMD160 value\n     * @property {number} BITCOIN=5 BITCOIN value\n     * @property {number} SHA512_256=6 SHA512_256 value\n     */\n    ics23.HashOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_HASH\"] = 0;\n        values[valuesById[1] = \"SHA256\"] = 1;\n        values[valuesById[2] = \"SHA512\"] = 2;\n        values[valuesById[3] = \"KECCAK\"] = 3;\n        values[valuesById[4] = \"RIPEMD160\"] = 4;\n        values[valuesById[5] = \"BITCOIN\"] = 5;\n        values[valuesById[6] = \"SHA512_256\"] = 6;\n        return values;\n    })();\n\n    /**\n     * LengthOp defines how to process the key and value of the LeafOp\n     * to include length information. After encoding the length with the given\n     * algorithm, the length will be prepended to the key and value bytes.\n     * (Each one with it's own encoded length)\n     * @name ics23.LengthOp\n     * @enum {string}\n     * @property {number} NO_PREFIX=0 NO_PREFIX value\n     * @property {number} VAR_PROTO=1 VAR_PROTO value\n     * @property {number} VAR_RLP=2 VAR_RLP value\n     * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n     * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n     * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n     * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n     * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n     * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n     */\n    ics23.LengthOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_PREFIX\"] = 0;\n        values[valuesById[1] = \"VAR_PROTO\"] = 1;\n        values[valuesById[2] = \"VAR_RLP\"] = 2;\n        values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n        values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n        values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n        values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n        values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n        values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n        return values;\n    })();\n\n    ics23.ExistenceProof = (function() {\n\n        /**\n         * Properties of an ExistenceProof.\n         * @memberof ics23\n         * @interface IExistenceProof\n         * @property {Uint8Array|null} [key] ExistenceProof key\n         * @property {Uint8Array|null} [value] ExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n         * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n         */\n\n        /**\n         * Constructs a new ExistenceProof.\n         * @memberof ics23\n         * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n         * The result of peforming all these steps will provide a \"root hash\", which can\n         * be compared to the value in a header.\n         * \n         * Since it is computationally infeasible to produce a hash collission for any of the used\n         * cryptographic hash functions, if someone can provide a series of operations to transform\n         * a given key and value into a root hash that matches some trusted root, these key and values\n         * must be in the referenced merkle tree.\n         * \n         * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n         * which should be controlled by a spec. Eg. with lengthOp as NONE,\n         * prefix = FOO, key = BAR, value = CHOICE\n         * and\n         * prefix = F, key = OOBAR, value = CHOICE\n         * would produce the same value.\n         * \n         * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n         * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n         * length-prefix the data before hashing it.\n         * @implements IExistenceProof\n         * @constructor\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         */\n        function ExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.leaf = null;\n\n        /**\n         * ExistenceProof path.\n         * @member {Array.<ics23.IInnerOp>} path\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new ExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         * @returns {ics23.ExistenceProof} ExistenceProof instance\n         */\n        ExistenceProof.create = function create(properties) {\n            return new ExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length)\n                for (var i = 0; i < message.path.length; ++i)\n                    $root.ics23.InnerOp.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an ExistenceProof message.\n         * @function verify\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.path[i]);\n                    if (error)\n                        return \"path.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         */\n        ExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ExistenceProof)\n                return object;\n            var message = new $root.ics23.ExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i) {\n                    if (typeof object.path[i] !== \"object\")\n                        throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n                    message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.ExistenceProof} message ExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.ExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ExistenceProof;\n    })();\n\n    ics23.NonExistenceProof = (function() {\n\n        /**\n         * Properties of a NonExistenceProof.\n         * @memberof ics23\n         * @interface INonExistenceProof\n         * @property {Uint8Array|null} [key] NonExistenceProof key\n         * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n         * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n         */\n\n        /**\n         * Constructs a new NonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a NonExistenceProof.\n         * @implements INonExistenceProof\n         * @constructor\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         */\n        function NonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * NonExistenceProof left.\n         * @member {ics23.IExistenceProof|null|undefined} left\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.left = null;\n\n        /**\n         * NonExistenceProof right.\n         * @member {ics23.IExistenceProof|null|undefined} right\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new NonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n         */\n        NonExistenceProof.create = function create(properties) {\n            return new NonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.ExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.ExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NonExistenceProof message.\n         * @function verify\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         */\n        NonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.NonExistenceProof)\n                return object;\n            var message = new $root.ics23.NonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n                message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n                message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.NonExistenceProof} message NonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this NonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NonExistenceProof;\n    })();\n\n    ics23.CommitmentProof = (function() {\n\n        /**\n         * Properties of a CommitmentProof.\n         * @memberof ics23\n         * @interface ICommitmentProof\n         * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n         * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n         * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n         */\n\n        /**\n         * Constructs a new CommitmentProof.\n         * @memberof ics23\n         * @classdesc Represents a CommitmentProof.\n         * @implements ICommitmentProof\n         * @constructor\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         */\n        function CommitmentProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CommitmentProof exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.exist = null;\n\n        /**\n         * CommitmentProof nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.nonexist = null;\n\n        /**\n         * CommitmentProof batch.\n         * @member {ics23.IBatchProof|null|undefined} batch\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.batch = null;\n\n        /**\n         * CommitmentProof compressed.\n         * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.compressed = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CommitmentProof proof.\n         * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CommitmentProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         * @returns {ics23.CommitmentProof} CommitmentProof instance\n         */\n        CommitmentProof.create = function create(properties) {\n            return new CommitmentProof(properties);\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.batch != null && message.hasOwnProperty(\"batch\"))\n                $root.ics23.BatchProof.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\"))\n                $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CommitmentProof message.\n         * @function verify\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CommitmentProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.BatchProof.verify(message.batch);\n                    if (error)\n                        return \"batch.\" + error;\n                }\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n                    if (error)\n                        return \"compressed.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         */\n        CommitmentProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CommitmentProof)\n                return object;\n            var message = new $root.ics23.CommitmentProof();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            if (object.batch != null) {\n                if (typeof object.batch !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n                message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n            }\n            if (object.compressed != null) {\n                if (typeof object.compressed !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n                message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.CommitmentProof} message CommitmentProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CommitmentProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n                if (options.oneofs)\n                    object.proof = \"batch\";\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n                if (options.oneofs)\n                    object.proof = \"compressed\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CommitmentProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CommitmentProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CommitmentProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitmentProof;\n    })();\n\n    ics23.LeafOp = (function() {\n\n        /**\n         * Properties of a LeafOp.\n         * @memberof ics23\n         * @interface ILeafOp\n         * @property {ics23.HashOp|null} [hash] LeafOp hash\n         * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n         * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n         * @property {ics23.LengthOp|null} [length] LeafOp length\n         * @property {Uint8Array|null} [prefix] LeafOp prefix\n         */\n\n        /**\n         * Constructs a new LeafOp.\n         * @memberof ics23\n         * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n         * must be flexible to represent the internal transformation from\n         * the original key-value pairs into the basis hash, for many existing\n         * merkle trees.\n         * \n         * key and value are passed in. So that the signature of this operation is:\n         * leafOp(key, value) -> output\n         * \n         * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n         * hkey = prehashKey(key)\n         * hvalue = prehashValue(value)\n         * \n         * Then combine the bytes, and hash it\n         * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n         * @implements ILeafOp\n         * @constructor\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         */\n        function LeafOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LeafOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.hash = 0;\n\n        /**\n         * LeafOp prehashKey.\n         * @member {ics23.HashOp} prehashKey\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashKey = 0;\n\n        /**\n         * LeafOp prehashValue.\n         * @member {ics23.HashOp} prehashValue\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashValue = 0;\n\n        /**\n         * LeafOp length.\n         * @member {ics23.LengthOp} length\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.length = 0;\n\n        /**\n         * LeafOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * Creates a new LeafOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         * @returns {ics23.LeafOp} LeafOp instance\n         */\n        LeafOp.create = function create(properties) {\n            return new LeafOp(properties);\n        };\n\n        /**\n         * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.prehashKey);\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.prehashValue);\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.prefix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LeafOp message.\n         * @function verify\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LeafOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                switch (message.prehashKey) {\n                default:\n                    return \"prehashKey: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                switch (message.prehashValue) {\n                default:\n                    return \"prehashValue: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                switch (message.length) {\n                default:\n                    return \"length: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.LeafOp} LeafOp\n         */\n        LeafOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.LeafOp)\n                return object;\n            var message = new $root.ics23.LeafOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            switch (object.prehashKey) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashKey = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashKey = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashKey = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashKey = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashKey = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashKey = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashKey = 6;\n                break;\n            }\n            switch (object.prehashValue) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashValue = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashValue = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashValue = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashValue = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashValue = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashValue = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashValue = 6;\n                break;\n            }\n            switch (object.length) {\n            case \"NO_PREFIX\":\n            case 0:\n                message.length = 0;\n                break;\n            case \"VAR_PROTO\":\n            case 1:\n                message.length = 1;\n                break;\n            case \"VAR_RLP\":\n            case 2:\n                message.length = 2;\n                break;\n            case \"FIXED32_BIG\":\n            case 3:\n                message.length = 3;\n                break;\n            case \"FIXED32_LITTLE\":\n            case 4:\n                message.length = 4;\n                break;\n            case \"FIXED64_BIG\":\n            case 5:\n                message.length = 5;\n                break;\n            case \"FIXED64_LITTLE\":\n            case 6:\n                message.length = 6;\n                break;\n            case \"REQUIRE_32_BYTES\":\n            case 7:\n                message.length = 7;\n                break;\n            case \"REQUIRE_64_BYTES\":\n            case 8:\n                message.length = 8;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.LeafOp} message LeafOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LeafOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n                object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            return object;\n        };\n\n        /**\n         * Converts this LeafOp to JSON.\n         * @function toJSON\n         * @memberof ics23.LeafOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LeafOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LeafOp;\n    })();\n\n    ics23.InnerOp = (function() {\n\n        /**\n         * Properties of an InnerOp.\n         * @memberof ics23\n         * @interface IInnerOp\n         * @property {ics23.HashOp|null} [hash] InnerOp hash\n         * @property {Uint8Array|null} [prefix] InnerOp prefix\n         * @property {Uint8Array|null} [suffix] InnerOp suffix\n         */\n\n        /**\n         * Constructs a new InnerOp.\n         * @memberof ics23\n         * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n         * It represents concatenating two children and hashing them to provide the next result.\n         * \n         * The result of the previous step is passed in, so the signature of this op is:\n         * innerOp(child) -> output\n         * \n         * The result of applying InnerOp should be:\n         * output = op.hash(op.prefix || child || op.suffix)\n         * \n         * where the || operator is concatenation of binary data,\n         * and child is the result of hashing all the tree below this step.\n         * \n         * Any special data, like prepending child with the length, or prepending the entire operation with\n         * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n         * If either of prefix or suffix is empty, we just treat it as an empty string\n         * @implements IInnerOp\n         * @constructor\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         */\n        function InnerOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.hash = 0;\n\n        /**\n         * InnerOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * InnerOp suffix.\n         * @member {Uint8Array} suffix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.suffix = $util.newBuffer([]);\n\n        /**\n         * Creates a new InnerOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         * @returns {ics23.InnerOp} InnerOp instance\n         */\n        InnerOp.create = function create(properties) {\n            return new InnerOp(properties);\n        };\n\n        /**\n         * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.suffix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerOp message.\n         * @function verify\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix)))\n                    return \"suffix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerOp} InnerOp\n         */\n        InnerOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerOp)\n                return object;\n            var message = new $root.ics23.InnerOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            if (object.suffix != null)\n                if (typeof object.suffix === \"string\")\n                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);\n                else if (object.suffix.length)\n                    message.suffix = object.suffix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.InnerOp} message InnerOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n                if (options.bytes === String)\n                    object.suffix = \"\";\n                else {\n                    object.suffix = [];\n                    if (options.bytes !== Array)\n                        object.suffix = $util.newBuffer(object.suffix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n            return object;\n        };\n\n        /**\n         * Converts this InnerOp to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerOp;\n    })();\n\n    ics23.ProofSpec = (function() {\n\n        /**\n         * Properties of a ProofSpec.\n         * @memberof ics23\n         * @interface IProofSpec\n         * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n         * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n         * @property {number|null} [maxDepth] ProofSpec maxDepth\n         * @property {number|null} [minDepth] ProofSpec minDepth\n         */\n\n        /**\n         * Constructs a new ProofSpec.\n         * @memberof ics23\n         * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n         * This can be stored in the client and used to validate any incoming proofs.\n         * \n         * verify(ProofSpec, Proof) -> Proof | Error\n         * \n         * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n         * LeafHash for a given tree, there are many possible key-value pairs that can\n         * generate a given hash (by interpretting the preimage differently).\n         * We need this for proper security, requires client knows a priori what\n         * tree format server uses. But not in code, rather a configuration object.\n         * @implements IProofSpec\n         * @constructor\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         */\n        function ProofSpec(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ProofSpec leafSpec.\n         * @member {ics23.ILeafOp|null|undefined} leafSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.leafSpec = null;\n\n        /**\n         * ProofSpec innerSpec.\n         * @member {ics23.IInnerSpec|null|undefined} innerSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.innerSpec = null;\n\n        /**\n         * ProofSpec maxDepth.\n         * @member {number} maxDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.maxDepth = 0;\n\n        /**\n         * ProofSpec minDepth.\n         * @member {number} minDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.minDepth = 0;\n\n        /**\n         * Creates a new ProofSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         * @returns {ics23.ProofSpec} ProofSpec instance\n         */\n        ProofSpec.create = function create(properties) {\n            return new ProofSpec(properties);\n        };\n\n        /**\n         * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDepth);\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minDepth);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ProofSpec message.\n         * @function verify\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ProofSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n                var error = $root.ics23.LeafOp.verify(message.leafSpec);\n                if (error)\n                    return \"leafSpec.\" + error;\n            }\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n                var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n                if (error)\n                    return \"innerSpec.\" + error;\n            }\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                if (!$util.isInteger(message.maxDepth))\n                    return \"maxDepth: integer expected\";\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                if (!$util.isInteger(message.minDepth))\n                    return \"minDepth: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ProofSpec} ProofSpec\n         */\n        ProofSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ProofSpec)\n                return object;\n            var message = new $root.ics23.ProofSpec();\n            if (object.leafSpec != null) {\n                if (typeof object.leafSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n                message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n            }\n            if (object.innerSpec != null) {\n                if (typeof object.innerSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n                message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n            }\n            if (object.maxDepth != null)\n                message.maxDepth = object.maxDepth | 0;\n            if (object.minDepth != null)\n                message.minDepth = object.minDepth | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.ProofSpec} message ProofSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ProofSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.leafSpec = null;\n                object.innerSpec = null;\n                object.maxDepth = 0;\n                object.minDepth = 0;\n            }\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                object.maxDepth = message.maxDepth;\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                object.minDepth = message.minDepth;\n            return object;\n        };\n\n        /**\n         * Converts this ProofSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.ProofSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ProofSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofSpec;\n    })();\n\n    ics23.InnerSpec = (function() {\n\n        /**\n         * Properties of an InnerSpec.\n         * @memberof ics23\n         * @interface IInnerSpec\n         * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n         * @property {number|null} [childSize] InnerSpec childSize\n         * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n         * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n         * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n         * @property {ics23.HashOp|null} [hash] InnerSpec hash\n         */\n\n        /**\n         * Constructs a new InnerSpec.\n         * @memberof ics23\n         * @classdesc Represents an InnerSpec.\n         * @implements IInnerSpec\n         * @constructor\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         */\n        function InnerSpec(properties) {\n            this.childOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerSpec childOrder.\n         * @member {Array.<number>} childOrder\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childOrder = $util.emptyArray;\n\n        /**\n         * InnerSpec childSize.\n         * @member {number} childSize\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childSize = 0;\n\n        /**\n         * InnerSpec minPrefixLength.\n         * @member {number} minPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.minPrefixLength = 0;\n\n        /**\n         * InnerSpec maxPrefixLength.\n         * @member {number} maxPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.maxPrefixLength = 0;\n\n        /**\n         * InnerSpec emptyChild.\n         * @member {Uint8Array} emptyChild\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n\n        /**\n         * InnerSpec hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.hash = 0;\n\n        /**\n         * Creates a new InnerSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         * @returns {ics23.InnerSpec} InnerSpec instance\n         */\n        InnerSpec.create = function create(properties) {\n            return new InnerSpec(properties);\n        };\n\n        /**\n         * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.childOrder != null && message.childOrder.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    writer.int32(message.childOrder[i]);\n                writer.ldelim();\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.childSize);\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minPrefixLength);\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxPrefixLength);\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.emptyChild);\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hash);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.childOrder && message.childOrder.length))\n                        message.childOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.childOrder.push(reader.int32());\n                    } else\n                        message.childOrder.push(reader.int32());\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerSpec message.\n         * @function verify\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n                if (!Array.isArray(message.childOrder))\n                    return \"childOrder: array expected\";\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    if (!$util.isInteger(message.childOrder[i]))\n                        return \"childOrder: integer[] expected\";\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                if (!$util.isInteger(message.childSize))\n                    return \"childSize: integer expected\";\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                if (!$util.isInteger(message.minPrefixLength))\n                    return \"minPrefixLength: integer expected\";\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                if (!$util.isInteger(message.maxPrefixLength))\n                    return \"maxPrefixLength: integer expected\";\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild)))\n                    return \"emptyChild: buffer expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerSpec} InnerSpec\n         */\n        InnerSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerSpec)\n                return object;\n            var message = new $root.ics23.InnerSpec();\n            if (object.childOrder) {\n                if (!Array.isArray(object.childOrder))\n                    throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n                message.childOrder = [];\n                for (var i = 0; i < object.childOrder.length; ++i)\n                    message.childOrder[i] = object.childOrder[i] | 0;\n            }\n            if (object.childSize != null)\n                message.childSize = object.childSize | 0;\n            if (object.minPrefixLength != null)\n                message.minPrefixLength = object.minPrefixLength | 0;\n            if (object.maxPrefixLength != null)\n                message.maxPrefixLength = object.maxPrefixLength | 0;\n            if (object.emptyChild != null)\n                if (typeof object.emptyChild === \"string\")\n                    $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);\n                else if (object.emptyChild.length)\n                    message.emptyChild = object.emptyChild;\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.InnerSpec} message InnerSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childOrder = [];\n            if (options.defaults) {\n                object.childSize = 0;\n                object.minPrefixLength = 0;\n                object.maxPrefixLength = 0;\n                if (options.bytes === String)\n                    object.emptyChild = \"\";\n                else {\n                    object.emptyChild = [];\n                    if (options.bytes !== Array)\n                        object.emptyChild = $util.newBuffer(object.emptyChild);\n                }\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n            }\n            if (message.childOrder && message.childOrder.length) {\n                object.childOrder = [];\n                for (var j = 0; j < message.childOrder.length; ++j)\n                    object.childOrder[j] = message.childOrder[j];\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                object.childSize = message.childSize;\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                object.minPrefixLength = message.minPrefixLength;\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                object.maxPrefixLength = message.maxPrefixLength;\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            return object;\n        };\n\n        /**\n         * Converts this InnerSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerSpec;\n    })();\n\n    ics23.BatchProof = (function() {\n\n        /**\n         * Properties of a BatchProof.\n         * @memberof ics23\n         * @interface IBatchProof\n         * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n         */\n\n        /**\n         * Constructs a new BatchProof.\n         * @memberof ics23\n         * @classdesc Represents a BatchProof.\n         * @implements IBatchProof\n         * @constructor\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         */\n        function BatchProof(properties) {\n            this.entries = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchProof entries.\n         * @member {Array.<ics23.IBatchEntry>} entries\n         * @memberof ics23.BatchProof\n         * @instance\n         */\n        BatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * Creates a new BatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         * @returns {ics23.BatchProof} BatchProof instance\n         */\n        BatchProof.create = function create(properties) {\n            return new BatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchProof message.\n         * @function verify\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchProof} BatchProof\n         */\n        BatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchProof)\n                return object;\n            var message = new $root.ics23.BatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.BatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.BatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.BatchProof} message BatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.entries = [];\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchProof;\n    })();\n\n    ics23.BatchEntry = (function() {\n\n        /**\n         * Properties of a BatchEntry.\n         * @memberof ics23\n         * @interface IBatchEntry\n         * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new BatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a BatchEntry.\n         * @implements IBatchEntry\n         * @constructor\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         */\n        function BatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchEntry exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.exist = null;\n\n        /**\n         * BatchEntry nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * BatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        Object.defineProperty(BatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new BatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         * @returns {ics23.BatchEntry} BatchEntry instance\n         */\n        BatchEntry.create = function create(properties) {\n            return new BatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchEntry message.\n         * @function verify\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchEntry} BatchEntry\n         */\n        BatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchEntry)\n                return object;\n            var message = new $root.ics23.BatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.BatchEntry} message BatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchEntry;\n    })();\n\n    ics23.CompressedBatchProof = (function() {\n\n        /**\n         * Properties of a CompressedBatchProof.\n         * @memberof ics23\n         * @interface ICompressedBatchProof\n         * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n         * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n         */\n\n        /**\n         * Constructs a new CompressedBatchProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchProof.\n         * @implements ICompressedBatchProof\n         * @constructor\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         */\n        function CompressedBatchProof(properties) {\n            this.entries = [];\n            this.lookupInners = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchProof entries.\n         * @member {Array.<ics23.ICompressedBatchEntry>} entries\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * CompressedBatchProof lookupInners.\n         * @member {Array.<ics23.IInnerOp>} lookupInners\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedBatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n         */\n        CompressedBatchProof.create = function create(properties) {\n            return new CompressedBatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.lookupInners != null && message.lookupInners.length)\n                for (var i = 0; i < message.lookupInners.length; ++i)\n                    $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.lookupInners && message.lookupInners.length))\n                        message.lookupInners = [];\n                    message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchProof message.\n         * @function verify\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n                if (!Array.isArray(message.lookupInners))\n                    return \"lookupInners: array expected\";\n                for (var i = 0; i < message.lookupInners.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n                    if (error)\n                        return \"lookupInners.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         */\n        CompressedBatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchProof)\n                return object;\n            var message = new $root.ics23.CompressedBatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            if (object.lookupInners) {\n                if (!Array.isArray(object.lookupInners))\n                    throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n                message.lookupInners = [];\n                for (var i = 0; i < object.lookupInners.length; ++i) {\n                    if (typeof object.lookupInners[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n                    message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.entries = [];\n                object.lookupInners = [];\n            }\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n            }\n            if (message.lookupInners && message.lookupInners.length) {\n                object.lookupInners = [];\n                for (var j = 0; j < message.lookupInners.length; ++j)\n                    object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchProof;\n    })();\n\n    ics23.CompressedBatchEntry = (function() {\n\n        /**\n         * Properties of a CompressedBatchEntry.\n         * @memberof ics23\n         * @interface ICompressedBatchEntry\n         * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n         * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new CompressedBatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchEntry.\n         * @implements ICompressedBatchEntry\n         * @constructor\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         */\n        function CompressedBatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchEntry exist.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.exist = null;\n\n        /**\n         * CompressedBatchEntry nonexist.\n         * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CompressedBatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CompressedBatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n         */\n        CompressedBatchEntry.create = function create(properties) {\n            return new CompressedBatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchEntry message.\n         * @function verify\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         */\n        CompressedBatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchEntry)\n                return object;\n            var message = new $root.ics23.CompressedBatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n                message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchEntry;\n    })();\n\n    ics23.CompressedExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedExistenceProof\n         * @property {Uint8Array|null} [key] CompressedExistenceProof key\n         * @property {Uint8Array|null} [value] CompressedExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n         * @property {Array.<number>|null} [path] CompressedExistenceProof path\n         */\n\n        /**\n         * Constructs a new CompressedExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedExistenceProof.\n         * @implements ICompressedExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         */\n        function CompressedExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.leaf = null;\n\n        /**\n         * CompressedExistenceProof path.\n         * @member {Array.<number>} path\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n         */\n        CompressedExistenceProof.create = function create(properties) {\n            return new CompressedExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.path.length; ++i)\n                    writer.int32(message.path[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.path.push(reader.int32());\n                    } else\n                        message.path.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i)\n                    if (!$util.isInteger(message.path[i]))\n                        return \"path: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         */\n        CompressedExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i)\n                    message.path[i] = object.path[i] | 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = message.path[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedExistenceProof;\n    })();\n\n    ics23.CompressedNonExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedNonExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedNonExistenceProof\n         * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n         * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n         * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n         */\n\n        /**\n         * Constructs a new CompressedNonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedNonExistenceProof.\n         * @implements ICompressedNonExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         */\n        function CompressedNonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedNonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedNonExistenceProof left.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} left\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.left = null;\n\n        /**\n         * CompressedNonExistenceProof right.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} right\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new CompressedNonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n         */\n        CompressedNonExistenceProof.create = function create(properties) {\n            return new CompressedNonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedNonExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedNonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         */\n        CompressedNonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedNonExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedNonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n                message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n                message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedNonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this CompressedNonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedNonExistenceProof;\n    })();\n\n    return ics23;\n})();\n\nmodule.exports = $root;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3167, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@confio/ics23/build/compress.js","sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/src/compress.ts"],"sourcesContent":["unable to read source [project]/node_modules/@confio/ics23/src/compress.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3281, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@confio/ics23/build/ops.js","sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/src/ops.ts"],"sourcesContent":["unable to read source [project]/node_modules/@confio/ics23/src/ops.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3413, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@confio/ics23/build/specs.js","sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/src/specs.ts"],"sourcesContent":["unable to read source [project]/node_modules/@confio/ics23/src/specs.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3530, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@confio/ics23/build/proofs.js","sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/src/proofs.ts"],"sourcesContent":["unable to read source [project]/node_modules/@confio/ics23/src/proofs.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3781, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@confio/ics23/build/ics23.js","sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/src/ics23.ts"],"sourcesContent":["unable to read source [project]/node_modules/@confio/ics23/src/ics23.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3889, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@confio/ics23/build/index.js","sources":["file:///home/asim/Chain/rollchain-explorer/node_modules/%40confio/ics23/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@confio/ics23/src/index.ts"],"names":[],"mappings":";;;;AAAA,IAAA,+CAA8C;AAArC,OAAA,cAAA,CAAA,SAAA,SAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,YAAA,KAAK;IAAA;AAAA,GAAA;AACd,IAAA,6BAAgE;AAAvD,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,QAAA,gBAAgB;IAAA;AAAA,GAAA;AAAE,OAAA,cAAA,CAAA,SAAA,uBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,QAAA,mBAAmB;IAAA;AAAA,GAAA;AAC9C,IAAA,+BAOkB;AANhB,OAAA,cAAA,CAAA,SAAA,0BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,sBAAsB;IAAA;AAAA,GAAA;AAEtB,OAAA,cAAA,CAAA,SAAA,YAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,QAAQ;IAAA;AAAA,GAAA;AACR,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,cAAc;IAAA;AAAA,GAAA;AACd,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,eAAe;IAAA;AAAA,GAAA;AACf,OAAA,cAAA,CAAA,SAAA,sBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,kBAAkB;IAAA;AAAA,GAAA"}}]
}