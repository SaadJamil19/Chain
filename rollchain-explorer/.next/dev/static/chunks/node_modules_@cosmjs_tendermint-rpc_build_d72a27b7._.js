(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@cosmjs/tendermint-rpc/build/addresses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/crypto/build/index.js [client] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
function rawEd25519PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
    }
    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
}
exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
    if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
    }
    return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
}
exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
/**
 * Returns Tendermint address as bytes.
 *
 * This is for addresses that are derived by the Tendermint keypair (typically Ed25519).
 * Sometimes those addresses are bech32-encoded and contain the term "cons" in the presix
 * ("cosmosvalcons1...").
 *
 * For secp256k1 this assumes we already have a compressed pubkey, which is the default in Cosmos.
 */ function pubkeyToRawAddress(type, data) {
    switch(type){
        case "ed25519":
            return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
            return rawSecp256k1PubkeyToRawAddress(data);
        default:
            // Keep this case here to guard against new types being added but not handled
            throw new Error(`Pubkey type ${type} not supported`);
    }
}
exports.pubkeyToRawAddress = pubkeyToRawAddress;
/**
 * Returns Tendermint address in uppercase hex format.
 *
 * This is for addresses that are derived by the Tendermint keypair (typically Ed25519).
 * Sometimes those addresses are bech32-encoded and contain the term "cons" in the presix
 * ("cosmosvalcons1...").
 *
 * For secp256k1 this assumes we already have a compressed pubkey, which is the default in Cosmos.
 */ function pubkeyToAddress(type, data) {
    return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
}
exports.pubkeyToAddress = pubkeyToAddress; //# sourceMappingURL=addresses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/dates.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DateTime = exports.toSeconds = exports.fromSeconds = exports.toRfc3339WithNanoseconds = exports.fromRfc3339WithNanoseconds = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
function fromRfc3339WithNanoseconds(dateTimeString) {
    const out = (0, encoding_1.fromRfc3339)(dateTimeString);
    const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
    const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
    out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
    return out;
}
exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
function toRfc3339WithNanoseconds(dateTime) {
    const millisecondIso = dateTime.toISOString();
    const nanoseconds = dateTime.nanoseconds?.toString() ?? "";
    return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
}
exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
function fromSeconds(seconds, nanos = 0) {
    const checkedNanos = new math_1.Uint32(nanos).toNumber();
    if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
    }
    const out = new Date(seconds * 1000 + Math.floor(checkedNanos / 1000000));
    out.nanoseconds = checkedNanos % 1000000;
    return out;
}
exports.fromSeconds = fromSeconds;
/**
 * Calculates the UNIX timestamp in seconds as well as the nanoseconds after the given second.
 *
 * This is useful when dealing with external systems like the protobuf type
 * [.google.protobuf.Timestamp](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp)
 * or any other system that does not use millisecond precision.
 */ function toSeconds(date) {
    return {
        seconds: Math.floor(date.getTime() / 1000),
        nanos: date.getTime() % 1000 * 1000000 + (date.nanoseconds ?? 0)
    };
}
exports.toSeconds = toSeconds;
/** @deprecated Use fromRfc3339WithNanoseconds/toRfc3339WithNanoseconds instead */ class DateTime {
    /** @deprecated Use fromRfc3339WithNanoseconds instead */ static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
    }
    /** @deprecated Use toRfc3339WithNanoseconds instead */ static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
    }
}
exports.DateTime = DateTime; //# sourceMappingURL=dates.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createJsonRpcRequest = void 0;
const numbersWithoutZero = "123456789";
/** generates a random numeric character  */ function randomNumericChar() {
    return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
}
/**
 * An (absolutely not cryptographically secure) random integer > 0.
 */ function randomId() {
    return parseInt(Array.from({
        length: 12
    }).map(()=>randomNumericChar()).join(""), 10);
}
/** Creates a JSON-RPC request with random ID */ // eslint-disable-next-line @typescript-eslint/ban-types
function createJsonRpcRequest(method, params) {
    const paramsCopy = params ? {
        ...params
    } : {};
    return {
        jsonrpc: "2.0",
        id: randomId(),
        method: method,
        params: paramsCopy
    };
}
exports.createJsonRpcRequest = createJsonRpcRequest; //# sourceMappingURL=jsonrpc.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.http = void 0;
const axios_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/axios/dist/browser/axios.cjs [client] (ecmascript)"));
function filterBadStatus(res) {
    if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
    }
    return res;
}
/**
 * Node.js 18 comes with exprimental fetch support (https://nodejs.org/de/blog/announcements/v18-release-announce/).
 * This is nice, but the implementation does not yet work wekk for us. We
 * can just stick with axios on those systems for now.
 */ // eslint-disable-next-line @typescript-eslint/ban-types
function isExperimental(nodeJsFunc) {
    // This works because we get this info in node 18:
    //
    // > fetch.toString()
    // 'async function fetch(input, init = undefined) {\n' +
    // "    emitExperimentalWarning('The Fetch API');\n" +
    // '    return lazyUndici().fetch(input, init);\n' +
    // '  }'
    return nodeJsFunc.toString().includes("emitExperimentalWarning");
}
/**
 * Helper to work around missing CORS support in Tendermint (https://github.com/tendermint/tendermint/pull/2800)
 *
 * For some reason, fetch does not complain about missing server-side CORS support.
 */ // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
async function http(method, url, headers, request) {
    if (typeof fetch === "function" && !isExperimental(fetch)) {
        const settings = {
            method: method,
            body: request ? JSON.stringify(request) : undefined,
            headers: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                "Content-Type": "application/json",
                ...headers
            }
        };
        return fetch(url, settings).then(filterBadStatus).then((res)=>res.json());
    } else {
        return axios_1.default.request({
            url: url,
            method: method,
            data: request,
            headers: headers
        }).then((res)=>res.data);
    }
}
exports.http = http; //# sourceMappingURL=http.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hasProtocol = exports.instanceOfRpcStreamingClient = void 0;
function instanceOfRpcStreamingClient(client) {
    return typeof client.listen === "function";
}
exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
// Helpers for all RPC clients
function hasProtocol(url) {
    return url.search("://") !== -1;
}
exports.hasProtocol = hasProtocol; //# sourceMappingURL=rpcclient.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpBatchClient = void 0;
const json_rpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/json-rpc/build/index.js [client] (ecmascript)");
const http_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js [client] (ecmascript)");
const rpcclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js [client] (ecmascript)");
// Those values are private and can change any time.
// Does a user need to know them? I don't think so. You either set
// a custom value or leave the option field unset.
const defaultHttpBatchClientOptions = {
    dispatchInterval: 20,
    batchSizeLimit: 20
};
class HttpBatchClient {
    constructor(endpoint, options = {}){
        this.queue = [];
        this.options = {
            batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
            dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval
        };
        if (typeof endpoint === "string") {
            if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
                throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
            }
            this.url = endpoint;
        } else {
            this.url = endpoint.url;
            this.headers = endpoint.headers;
        }
        this.timer = setInterval(()=>this.tick(), options.dispatchInterval);
        this.validate();
    }
    disconnect() {
        this.timer && clearInterval(this.timer);
        this.timer = undefined;
    }
    async execute(request) {
        return new Promise((resolve, reject)=>{
            this.queue.push({
                request,
                resolve,
                reject
            });
            if (this.queue.length >= this.options.batchSizeLimit) {
                // this train is full, let's go
                this.tick();
            }
        });
    }
    validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
            throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
    }
    /**
     * This is called in an interval where promise rejections cannot be handled.
     * So this is not async and HTTP errors need to be handled by the queued promises.
     */ tick() {
        // Avoid race conditions
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length) return;
        const requests = batch.map((s)=>s.request);
        const requestIds = requests.map((request)=>request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests).then((raw)=>{
            // Requests with a single entry return as an object
            const arr = Array.isArray(raw) ? raw : [
                raw
            ];
            arr.forEach((el)=>{
                const req = batch.find((s)=>s.request.id === el.id);
                if (!req) return;
                const { reject, resolve } = req;
                const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
                    reject(new Error(JSON.stringify(response.error)));
                } else {
                    resolve(response);
                }
            });
        }, (error)=>{
            for (const requestId of requestIds){
                const req = batch.find((s)=>s.request.id === requestId);
                if (!req) return;
                req.reject(error);
            }
        });
    }
}
exports.HttpBatchClient = HttpBatchClient; //# sourceMappingURL=httpbatchclient.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpClient = void 0;
const json_rpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/json-rpc/build/index.js [client] (ecmascript)");
const http_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js [client] (ecmascript)");
const rpcclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js [client] (ecmascript)");
class HttpClient {
    constructor(endpoint){
        if (typeof endpoint === "string") {
            if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
                throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
            }
            this.url = endpoint;
        } else {
            this.url = endpoint.url;
            this.headers = endpoint.headers;
        }
    }
    disconnect() {
    // nothing to be done
    }
    async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
            throw new Error(JSON.stringify(response.error));
        }
        return response;
    }
}
exports.HttpClient = HttpClient; //# sourceMappingURL=httpclient.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketClient = void 0;
const json_rpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/json-rpc/build/index.js [client] (ecmascript)");
const socket_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/socket/build/index.js [client] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/stream/build/index.js [client] (ecmascript)");
const xstream_1 = __turbopack_context__.r("[project]/node_modules/xstream/index.js [client] (ecmascript)");
const rpcclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js [client] (ecmascript)");
function defaultErrorHandler(error) {
    throw error;
}
function toJsonRpcResponse(message) {
    // this should never happen, but I want an alert if it does
    if (message.type !== "message") {
        throw new Error(`Unexcepted message type on websocket: ${message.type}`);
    }
    const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
    return jsonRpcEvent;
}
class RpcEventProducer {
    constructor(request, socket){
        this.running = false;
        this.subscriptions = [];
        this.request = request;
        this.socket = socket;
    }
    /**
     * Implementation of Producer.start
     */ start(listener) {
        if (this.running) {
            throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
    }
    /**
     * Implementation of Producer.stop
     *
     * Called by the stream when the stream's last listener stopped listening
     * or when the producer completed.
     */ stop() {
        this.running = false;
        // Tell the server we are done in order to save resources. We cannot wait for the result.
        // This may fail when socket connection is not open, thus ignore errors in queueRequest
        const endRequest = {
            ...this.request,
            method: "unsubscribe"
        };
        try {
            this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
            if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
            // ignore
            } else {
                throw error;
            }
        }
    }
    connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        // this should unsubscribe itself, so doesn't need to be removed explicitly
        const idSubscription = responseStream.filter((response)=>response.id === this.request.id).subscribe({
            next: (response)=>{
                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
                    this.closeSubscriptions();
                    listener.error(JSON.stringify(response.error));
                }
                idSubscription.unsubscribe();
            }
        });
        // this will fire on a response (success or error)
        // Tendermint adds an "#event" suffix for events that follow a previous subscription
        // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107
        const idEventSubscription = responseStream.filter((response)=>response.id === this.request.id).subscribe({
            next: (response)=>{
                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
                    this.closeSubscriptions();
                    listener.error(JSON.stringify(response.error));
                } else {
                    listener.next(response.result);
                }
            }
        });
        // this will fire in case the websocket disconnects cleanly
        const nonResponseSubscription = responseStream.subscribe({
            error: (error)=>{
                this.closeSubscriptions();
                listener.error(error);
            },
            complete: ()=>{
                this.closeSubscriptions();
                listener.complete();
            }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
    }
    closeSubscriptions() {
        for (const subscription of this.subscriptions){
            subscription.unsubscribe();
        }
        // clear unused subscriptions
        this.subscriptions = [];
    }
}
class WebsocketClient {
    constructor(baseUrl, onError = defaultErrorHandler){
        // Lazily create streams and use the same stream when listening to the same query twice.
        //
        // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this
        // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!
        this.subscriptionStreams = new Map();
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
            throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        // make sure we don't end up with ...//websocket
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
            error: (error)=>{
                onError(error);
                errorSubscription.unsubscribe();
            }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
    }
    async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
            throw new Error(JSON.stringify(response.error));
        }
        return response;
    }
    listen(request) {
        if (request.method !== "subscribe") {
            throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
            throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
            const producer = new RpcEventProducer(request, this.socket);
            const stream = xstream_1.Stream.create(producer);
            this.subscriptionStreams.set(query, stream);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.subscriptionStreams.get(query).filter((response)=>response.query !== undefined);
    }
    /**
     * Resolves as soon as websocket is connected. execute() queues requests automatically,
     * so this should be required for testing purposes only.
     */ async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
    }
    disconnect() {
        this.socket.disconnect();
    }
    async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r)=>r.id === id));
    }
}
exports.WebsocketClient = WebsocketClient; //# sourceMappingURL=websocketclient.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This folder contains Tendermint-specific RPC clients
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
var httpbatchclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js [client] (ecmascript)");
Object.defineProperty(exports, "HttpBatchClient", {
    enumerable: true,
    get: function() {
        return httpbatchclient_1.HttpBatchClient;
    }
});
var httpclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js [client] (ecmascript)");
Object.defineProperty(exports, "HttpClient", {
    enumerable: true,
    get: function() {
        return httpclient_1.HttpClient;
    }
});
var rpcclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js [client] (ecmascript)");
Object.defineProperty(exports, "instanceOfRpcStreamingClient", {
    enumerable: true,
    get: function() {
        return rpcclient_1.instanceOfRpcStreamingClient;
    }
});
var websocketclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js [client] (ecmascript)");
Object.defineProperty(exports, "WebsocketClient", {
    enumerable: true,
    get: function() {
        return websocketclient_1.WebsocketClient;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeUvarint = exports.encodeString = exports.dictionaryToStringMap = exports.may = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
/**
 * A runtime checker that ensures a given value is set (i.e. not undefined or null)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 */ function assertSet(value) {
    if (value === undefined) {
        throw new Error("Value must not be undefined");
    }
    if (value === null) {
        throw new Error("Value must not be null");
    }
    return value;
}
exports.assertSet = assertSet;
/**
 * A runtime checker that ensures a given value is a boolean
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertBoolean(value) {
    assertSet(value);
    if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
    }
    return value;
}
exports.assertBoolean = assertBoolean;
/**
 * A runtime checker that ensures a given value is a string.
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertString(value) {
    assertSet(value);
    if (typeof value !== "string") {
        throw new Error("Value must be a string");
    }
    return value;
}
exports.assertString = assertString;
/**
 * A runtime checker that ensures a given value is a number
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertNumber(value) {
    assertSet(value);
    if (typeof value !== "number") {
        throw new Error("Value must be a number");
    }
    return value;
}
exports.assertNumber = assertNumber;
/**
 * A runtime checker that ensures a given value is an array
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertArray(value) {
    assertSet(value);
    if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
    }
    return value;
}
exports.assertArray = assertArray;
/**
 * A runtime checker that ensures a given value is an object in the sense of JSON
 * (an unordered collection of key–value pairs where the keys are strings)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertObject(value) {
    assertSet(value);
    if (typeof value !== "object") {
        throw new Error("Value must be an object");
    }
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
    }
    return value;
}
exports.assertObject = assertObject;
/**
 * Throws an error if value matches the empty value for the
 * given type (array/string of length 0, number of value 0, ...)
 *
 * Otherwise returns the value.
 *
 * This implies assertSet
 */ function assertNotEmpty(value) {
    assertSet(value);
    if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
    } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
    }
    return value;
}
exports.assertNotEmpty = assertNotEmpty;
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
exports.may = may;
function dictionaryToStringMap(obj) {
    const out = new Map();
    for (const key of Object.keys(obj)){
        const value = obj[key];
        if (typeof value !== "string") {
            throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
    }
    return out;
}
exports.dictionaryToStringMap = dictionaryToStringMap;
// Encodings needed for hashing block headers
// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195
function encodeString(s) {
    const utf8 = (0, encoding_1.toUtf8)(s);
    return Uint8Array.from([
        utf8.length,
        ...utf8
    ]);
}
exports.encodeString = encodeString;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87
function encodeUvarint(n) {
    return n >= 0x80 ? Uint8Array.from([
        n & 0xff | 0x80,
        ...encodeUvarint(n >> 7)
    ]) : Uint8Array.from([
        n & 0xff
    ]);
}
exports.encodeUvarint = encodeUvarint;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178
function encodeTime(time) {
    const milliseconds = time.getTime();
    const seconds = Math.floor(milliseconds / 1000);
    const secondsArray = seconds ? [
        0x08,
        ...encodeUvarint(seconds)
    ] : new Uint8Array();
    const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;
    const nanosecondsArray = nanoseconds ? [
        0x10,
        ...encodeUvarint(nanoseconds)
    ] : new Uint8Array();
    return Uint8Array.from([
        ...secondsArray,
        ...nanosecondsArray
    ]);
}
exports.encodeTime = encodeTime;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187
function encodeBytes(bytes) {
    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet
    if (bytes.length >= 0x80) throw new Error("Not implemented for byte arrays of length 128 or more");
    return bytes.length ? Uint8Array.from([
        bytes.length,
        ...bytes
    ]) : new Uint8Array();
}
exports.encodeBytes = encodeBytes;
function encodeVersion(version) {
    const blockArray = version.block ? Uint8Array.from([
        0x08,
        ...encodeUvarint(version.block)
    ]) : new Uint8Array();
    const appArray = version.app ? Uint8Array.from([
        0x10,
        ...encodeUvarint(version.app)
    ]) : new Uint8Array();
    return Uint8Array.from([
        ...blockArray,
        ...appArray
    ]);
}
exports.encodeVersion = encodeVersion;
function encodeBlockId(blockId) {
    return Uint8Array.from([
        0x0a,
        blockId.hash.length,
        ...blockId.hash,
        0x12,
        blockId.parts.hash.length + 4,
        0x08,
        blockId.parts.total,
        0x12,
        blockId.parts.hash.length,
        ...blockId.parts.hash
    ]);
}
exports.encodeBlockId = encodeBlockId; //# sourceMappingURL=encodings.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.smallIntToApi = exports.apiToBigInt = exports.apiToSmallInt = void 0;
const math_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/math/build/index.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js [client] (ecmascript)");
/**
 * Takes an integer value from the Tendermint RPC API and
 * returns it as number.
 *
 * Only works within the safe integer range.
 */ function apiToSmallInt(input) {
    const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
    return asInt.toNumber();
}
exports.apiToSmallInt = apiToSmallInt;
/**
 * Takes an integer value from the Tendermint RPC API and
 * returns it as BigInt.
 *
 * This supports the full uint64 and int64 ranges.
 */ function apiToBigInt(input) {
    (0, encodings_1.assertString)(input); // Runtime check on top of TypeScript just to be safe for semi-trusted API types
    if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
    }
    return BigInt(input);
}
exports.apiToBigInt = apiToBigInt;
/**
 * Takes an integer in the safe integer range and returns
 * a string representation to be used in the Tendermint RPC API.
 */ function smallIntToApi(num) {
    return new math_1.Int53(num).toString();
}
exports.smallIntToApi = smallIntToApi; //# sourceMappingURL=inthelpers.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeUvarint = exports.encodeString = exports.dictionaryToStringMap = exports.may = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
/**
 * A runtime checker that ensures a given value is set (i.e. not undefined or null)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 */ function assertSet(value) {
    if (value === undefined) {
        throw new Error("Value must not be undefined");
    }
    if (value === null) {
        throw new Error("Value must not be null");
    }
    return value;
}
exports.assertSet = assertSet;
/**
 * A runtime checker that ensures a given value is a boolean
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertBoolean(value) {
    assertSet(value);
    if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
    }
    return value;
}
exports.assertBoolean = assertBoolean;
/**
 * A runtime checker that ensures a given value is a string.
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertString(value) {
    assertSet(value);
    if (typeof value !== "string") {
        throw new Error("Value must be a string");
    }
    return value;
}
exports.assertString = assertString;
/**
 * A runtime checker that ensures a given value is a number
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertNumber(value) {
    assertSet(value);
    if (typeof value !== "number") {
        throw new Error("Value must be a number");
    }
    return value;
}
exports.assertNumber = assertNumber;
/**
 * A runtime checker that ensures a given value is an array
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertArray(value) {
    assertSet(value);
    if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
    }
    return value;
}
exports.assertArray = assertArray;
/**
 * A runtime checker that ensures a given value is an object in the sense of JSON
 * (an unordered collection of key–value pairs where the keys are strings)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertObject(value) {
    assertSet(value);
    if (typeof value !== "object") {
        throw new Error("Value must be an object");
    }
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
    }
    return value;
}
exports.assertObject = assertObject;
/**
 * Throws an error if value matches the empty value for the
 * given type (array/string of length 0, number of value 0, ...)
 *
 * Otherwise returns the value.
 *
 * This implies assertSet
 */ function assertNotEmpty(value) {
    assertSet(value);
    if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
    } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
    }
    return value;
}
exports.assertNotEmpty = assertNotEmpty;
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
exports.may = may;
function dictionaryToStringMap(obj) {
    const out = new Map();
    for (const key of Object.keys(obj)){
        const value = obj[key];
        if (typeof value !== "string") {
            throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
    }
    return out;
}
exports.dictionaryToStringMap = dictionaryToStringMap;
// Encodings needed for hashing block headers
// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195
function encodeString(s) {
    const utf8 = (0, encoding_1.toUtf8)(s);
    return Uint8Array.from([
        utf8.length,
        ...utf8
    ]);
}
exports.encodeString = encodeString;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87
function encodeUvarint(n) {
    return n >= 0x80 ? Uint8Array.from([
        n & 0xff | 0x80,
        ...encodeUvarint(n >> 7)
    ]) : Uint8Array.from([
        n & 0xff
    ]);
}
exports.encodeUvarint = encodeUvarint;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178
function encodeTime(time) {
    const milliseconds = time.getTime();
    const seconds = Math.floor(milliseconds / 1000);
    const secondsArray = seconds ? [
        0x08,
        ...encodeUvarint(seconds)
    ] : new Uint8Array();
    const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;
    const nanosecondsArray = nanoseconds ? [
        0x10,
        ...encodeUvarint(nanoseconds)
    ] : new Uint8Array();
    return Uint8Array.from([
        ...secondsArray,
        ...nanosecondsArray
    ]);
}
exports.encodeTime = encodeTime;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187
function encodeBytes(bytes) {
    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet
    if (bytes.length >= 0x80) throw new Error("Not implemented for byte arrays of length 128 or more");
    return bytes.length ? Uint8Array.from([
        bytes.length,
        ...bytes
    ]) : new Uint8Array();
}
exports.encodeBytes = encodeBytes;
function encodeVersion(version) {
    const blockArray = version.block ? Uint8Array.from([
        0x08,
        ...encodeUvarint(version.block)
    ]) : new Uint8Array();
    const appArray = version.app ? Uint8Array.from([
        0x10,
        ...encodeUvarint(version.app)
    ]) : new Uint8Array();
    return Uint8Array.from([
        ...blockArray,
        ...appArray
    ]);
}
exports.encodeVersion = encodeVersion;
function encodeBlockId(blockId) {
    return Uint8Array.from([
        0x0a,
        blockId.hash.length,
        ...blockId.hash,
        0x12,
        blockId.parts.hash.length + 4,
        0x08,
        blockId.parts.total,
        0x12,
        blockId.parts.hash.length,
        ...blockId.parts.hash
    ]);
}
exports.encodeBlockId = encodeBlockId; //# sourceMappingURL=encodings.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
/**
 * RPC methods as documented in https://docs.tendermint.com/master/rpc/
 *
 * Enum raw value must match the spelling in the "shell" example call (snake_case)
 */ var Method;
(function(Method) {
    Method["AbciInfo"] = "abci_info";
    Method["AbciQuery"] = "abci_query";
    Method["Block"] = "block";
    /** Get block headers for minHeight <= height <= maxHeight. */ Method["Blockchain"] = "blockchain";
    Method["BlockResults"] = "block_results";
    Method["BlockSearch"] = "block_search";
    Method["BroadcastTxAsync"] = "broadcast_tx_async";
    Method["BroadcastTxSync"] = "broadcast_tx_sync";
    Method["BroadcastTxCommit"] = "broadcast_tx_commit";
    Method["Commit"] = "commit";
    Method["Genesis"] = "genesis";
    Method["Health"] = "health";
    Method["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
    Method["Status"] = "status";
    Method["Subscribe"] = "subscribe";
    Method["Tx"] = "tx";
    Method["TxSearch"] = "tx_search";
    Method["Validators"] = "validators";
    Method["Unsubscribe"] = "unsubscribe";
})(Method = exports.Method || (exports.Method = {}));
/**
 * Raw values must match the tendermint event name
 *
 * @see https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
 */ var SubscriptionEventType;
(function(SubscriptionEventType) {
    SubscriptionEventType["NewBlock"] = "NewBlock";
    SubscriptionEventType["NewBlockHeader"] = "NewBlockHeader";
    SubscriptionEventType["Tx"] = "Tx";
})(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
function buildQuery(components) {
    const tags = components.tags ? components.tags : [];
    const tagComponents = tags.map((tag)=>`${tag.key}='${tag.value}'`);
    const rawComponents = components.raw ? [
        components.raw
    ] : [];
    return [
        ...tagComponents,
        ...rawComponents
    ].join(" AND ");
}
exports.buildQuery = buildQuery; //# sourceMappingURL=requests.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const inthelpers_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)");
const jsonrpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js [client] (ecmascript)");
const requests = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js [client] (ecmascript)"));
function encodeHeightParam(param) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
    };
}
function encodeBlockchainRequestParams(param) {
    return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
    };
}
function encodeBlockSearchParams(params) {
    return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeAbciQueryParams(params) {
    return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
    };
}
function encodeBroadcastTxParams(params) {
    return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
    };
}
function encodeTxParams(params) {
    return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
    };
}
function encodeTxSearchParams(params) {
    return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeValidatorsParams(params) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
    };
}
class Params {
    static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
    }
    static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
    }
    static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
    }
    static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
    }
    static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeSubscribe(req) {
        const eventTag = {
            key: "tm.event",
            value: req.query.type
        };
        const query = requests.buildQuery({
            tags: [
                eventTag
            ],
            raw: req.query.raw
        });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", {
            query: query
        });
    }
    static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
    }
    // TODO: encode params for query string???
    static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
    }
    static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
    }
}
exports.Params = Params; //# sourceMappingURL=requests.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/types.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Types in this file are exported outside of the @cosmjs/tendermint-rpc package,
// e.g. as part of a request or response
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockIdFlag = void 0;
var BlockIdFlag;
(function(BlockIdFlag) {
    BlockIdFlag[BlockIdFlag["Unknown"] = 0] = "Unknown";
    BlockIdFlag[BlockIdFlag["Absent"] = 1] = "Absent";
    BlockIdFlag[BlockIdFlag["Commit"] = 2] = "Commit";
    BlockIdFlag[BlockIdFlag["Nil"] = 3] = "Nil";
    BlockIdFlag[BlockIdFlag["Unrecognized"] = -1] = "Unrecognized";
})(BlockIdFlag = exports.BlockIdFlag || (exports.BlockIdFlag = {})); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashBlock = exports.hashTx = void 0;
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/crypto/build/index.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js [client] (ecmascript)");
// hash is sha256
// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260
function hashTx(tx) {
    return (0, crypto_1.sha256)(tx);
}
exports.hashTx = hashTx;
function getSplitPoint(n) {
    if (n < 1) throw new Error("Cannot split an empty tree");
    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
}
function hashLeaf(leaf) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        0
    ]));
    hash.update(leaf);
    return hash.digest();
}
function hashInner(left, right) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        1
    ]));
    hash.update(left);
    hash.update(right);
    return hash.digest();
}
// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot
// Note: the hashes input may not actually be hashes, especially before a recursive call
function hashTree(hashes) {
    switch(hashes.length){
        case 0:
            throw new Error("Cannot hash empty tree");
        case 1:
            return hashLeaf(hashes[0]);
        default:
            {
                const slicePoint = getSplitPoint(hashes.length);
                const left = hashTree(hashes.slice(0, slicePoint));
                const right = hashTree(hashes.slice(slicePoint));
                return hashInner(left, right);
            }
    }
}
function hashBlock(header) {
    if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
    }
    const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
    ];
    return hashTree(encodedFields);
}
exports.hashBlock = hashBlock; //# sourceMappingURL=hasher.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const dates_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/dates.js [client] (ecmascript)");
const inthelpers_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/types.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js [client] (ecmascript)");
const hasher_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js [client] (ecmascript)");
function decodeAbciInfo(data) {
    return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
    };
}
function decodeQueryProof(data) {
    return {
        ops: data.ops.map((op)=>({
                type: op.type,
                key: (0, encoding_1.fromBase64)(op.key),
                data: (0, encoding_1.fromBase64)(op.data)
            }))
    };
}
function decodeAbciQuery(data) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
    };
}
function decodeEventAttribute(attribute) {
    return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
    };
}
function decodeAttributes(attributes) {
    return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
}
function decodeEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
    };
}
exports.decodeEvent = decodeEvent;
function decodeEvents(events) {
    return (0, encodings_1.assertArray)(events).map(decodeEvent);
}
function decodeTxData(data) {
    return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
    };
}
function decodePubkey(data) {
    if ("Sum" in data) {
        // we don't need to check type because we're checking algorithm
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
            algorithm,
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
    } else {
        switch(data.type){
            // go-amino special code
            case "tendermint/PubKeyEd25519":
                return {
                    algorithm: "ed25519",
                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
                };
            case "tendermint/PubKeySecp256k1":
                return {
                    algorithm: "secp256k1",
                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
                };
            default:
                throw new Error(`unknown pubkey type: ${data.type}`);
        }
    }
}
/**
 * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry
 *
 * > Add time_iota_ms to block's consensus parameters (not exposed to the application)
 * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310
 */ function decodeBlockParams(data) {
    return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
    };
}
function decodeEvidenceParams(data) {
    return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
    };
}
function decodeConsensusParams(data) {
    return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
    };
}
function decodeValidatorUpdate(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
    };
}
exports.decodeValidatorUpdate = decodeValidatorUpdate;
function decodeBlockResults(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
    };
}
function decodeBlockId(data) {
    return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
            total: (0, encodings_1.assertNotEmpty)(data.parts.total),
            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
    };
}
function decodeBlockVersion(data) {
    return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
    };
}
function decodeHeader(data) {
    return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
    };
}
function decodeBlockMeta(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
    };
}
function decodeBlockchain(data) {
    return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
    };
}
function decodeBroadcastTxSync(data) {
    return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
    };
}
function decodeBroadcastTxCommit(data) {
    const txResult = data.tx_result ? decodeTxData(data.tx_result) : undefined;
    return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: txResult,
        txResult: txResult
    };
}
function decodeBlockIdFlag(blockIdFlag) {
    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
    return blockIdFlag;
}
function decodeCommitSignature(data) {
    return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : undefined,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined
    };
}
function decodeCommit(data) {
    return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
    };
}
function decodeCommitResponse(data) {
    return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
    };
}
function decodeValidatorGenesis(data) {
    return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
    };
}
exports.decodeValidatorGenesis = decodeValidatorGenesis;
function decodeGenesis(data) {
    return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
    };
}
function decodeValidatorInfo(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined
    };
}
exports.decodeValidatorInfo = decodeValidatorInfo;
function decodeNodeInfo(data) {
    return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertString)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
            app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
            block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
            p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
    };
}
function decodeSyncInfo(data) {
    const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : undefined;
    const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : undefined;
    return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : undefined,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : undefined,
        earliestBlockHeight: earliestBlockHeight || undefined,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : undefined,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
    };
}
function decodeStatus(data) {
    return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
    };
}
function decodeTxProof(data) {
    return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
            total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
            index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
    };
}
function decodeTxResponse(data) {
    return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
    };
}
function decodeTxSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
    };
}
function decodeTxEvent(data) {
    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
    return {
        tx: tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
    };
}
function decodeValidators(data) {
    return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
    };
}
function decodeBlock(data) {
    return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
    };
}
function decodeBlockResponse(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
    };
}
function decodeBlockSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
    };
}
function decodeNumUnconfirmedTxs(data) {
    return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
    };
}
class Responses {
    static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeBlock(response) {
        return decodeBlockResponse(response.result);
    }
    static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
    }
    static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
    }
    static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
    }
    static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
    }
    static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
    }
    static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
    }
    static decodeCommit(response) {
        return decodeCommitResponse(response.result);
    }
    static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
    }
    static decodeHealth() {
        return null;
    }
    static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
    }
    static decodeStatus(response) {
        return decodeStatus(response.result);
    }
    static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
    }
    static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
    }
    static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
    }
    static decodeTx(response) {
        return decodeTxResponse(response.result);
    }
    static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
    }
    static decodeValidators(response) {
        return decodeValidators(response.result);
    }
}
exports.Responses = Responses; //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.Params = void 0;
var requests_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js [client] (ecmascript)");
Object.defineProperty(exports, "Params", {
    enumerable: true,
    get: function() {
        return requests_1.Params;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js [client] (ecmascript)");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Comet38Client = void 0;
const jsonrpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)");
const rpcclients_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js [client] (ecmascript)");
const adaptor_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js [client] (ecmascript)");
const requests = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js [client] (ecmascript)"));
class Comet38Client {
    /**
     * Creates a new Tendermint client for the given endpoint.
     *
     * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
     */ static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
            rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
            const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
            rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        // For some very strange reason I don't understand, tests start to fail on some systems
        // (our CI) when skipping the status call before doing other queries. Sleeping a little
        // while did not help. Thus we query the version as a way to say "hi" to the backend,
        // even in cases where we don't use the result.
        const _version = await this.detectVersion(rpcClient);
        return Comet38Client.create(rpcClient);
    }
    /**
     * Creates a new Tendermint client given an RPC client.
     */ static async create(rpcClient) {
        return new Comet38Client(rpcClient);
    }
    static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
            throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
            throw new Error("Unrecognized version format: must be string");
        }
        return version;
    }
    /**
     * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
     */ constructor(client){
        this.client = client;
    }
    disconnect() {
        this.client.disconnect();
    }
    async abciInfo() {
        const query = {
            method: requests.Method.AbciInfo
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
    }
    async abciQuery(params) {
        const query = {
            params: params,
            method: requests.Method.AbciQuery
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
    }
    async block(height) {
        const query = {
            method: requests.Method.Block,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
    }
    async blockResults(height) {
        const query = {
            method: requests.Method.BlockResults,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
    }
    /**
     * Search for events that are in a block.
     *
     * NOTE
     * This method will error on any node that is running a Tendermint version lower than 0.34.9.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
     */ async blockSearch(params) {
        const query = {
            params: params,
            method: requests.Method.BlockSearch
        };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
            ...resp,
            // make sure we sort by height, as tendermint may be sorting by string value of the height
            blocks: [
                ...resp.blocks
            ].sort((a, b)=>a.block.header.height - b.block.header.height)
        };
    }
    // this should paginate through all blockSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    //
    // NOTE
    // This method will error on any node that is running a Tendermint version lower than 0.34.9.
    async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while(!done){
            const resp = await this.blockSearch({
                ...params,
                page: page
            });
            blocks.push(...resp.blocks);
            if (blocks.length < resp.totalCount) {
                page++;
            } else {
                done = true;
            }
        }
        // make sure we sort by height, as tendermint may be sorting by string value of the height
        // and the earlier items may be in a higher page than the later items
        blocks.sort((a, b)=>a.block.header.height - b.block.header.height);
        return {
            totalCount: blocks.length,
            blocks: blocks
        };
    }
    /**
     * Queries block headers filtered by minHeight <= height <= maxHeight.
     *
     * @param minHeight The minimum height to be included in the result. Defaults to 0.
     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
     */ async blockchain(minHeight, maxHeight) {
        const query = {
            method: requests.Method.Blockchain,
            params: {
                minHeight: minHeight,
                maxHeight: maxHeight
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
    }
    /**
     * Broadcast transaction to mempool and wait for response
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */ async broadcastTxSync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxSync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
    }
    /**
     * Broadcast transaction to mempool and do not wait for result
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */ async broadcastTxAsync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxAsync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
    }
    /**
     * Broadcast transaction to mempool and wait for block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
     */ async broadcastTxCommit(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxCommit
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
    }
    async commit(height) {
        const query = {
            method: requests.Method.Commit,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
    }
    async genesis() {
        const query = {
            method: requests.Method.Genesis
        };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
    }
    async health() {
        const query = {
            method: requests.Method.Health
        };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
    }
    async numUnconfirmedTxs() {
        const query = {
            method: requests.Method.NumUnconfirmedTxs
        };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
    }
    async status() {
        const query = {
            method: requests.Method.Status
        };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
    }
    subscribeNewBlock() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlock
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
    }
    subscribeNewBlockHeader() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlockHeader
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
    }
    subscribeTx(query) {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.Tx,
                raw: query
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
    }
    /**
     * Get a single transaction by hash
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx
     */ async tx(params) {
        const query = {
            params: params,
            method: requests.Method.Tx
        };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
    }
    /**
     * Search for transactions that are in a block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
     */ async txSearch(params) {
        const query = {
            params: params,
            method: requests.Method.TxSearch
        };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
    }
    // this should paginate through all txSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while(!done){
            const resp = await this.txSearch({
                ...params,
                page: page
            });
            txs.push(...resp.txs);
            if (txs.length < resp.totalCount) {
                page++;
            } else {
                done = true;
            }
        }
        return {
            totalCount: txs.length,
            txs: txs
        };
    }
    async validators(params) {
        const query = {
            method: requests.Method.Validators,
            params: params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
    }
    async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while(!done){
            const response = await this.validators({
                per_page: 50,
                height: blockHeight,
                page: page
            });
            validators.push(...response.validators);
            blockHeight = blockHeight || response.blockHeight;
            if (validators.length < response.total) {
                page++;
            } else {
                done = true;
            }
        }
        return {
            // NOTE: Default value is for type safety but this should always be set
            blockHeight: blockHeight ?? 0,
            count: validators.length,
            total: validators.length,
            validators: validators
        };
    }
    // doCall is a helper to handle the encode/call/decode logic
    async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
    }
    subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
            throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event)=>{
            return decode(event);
        });
    }
}
exports.Comet38Client = Comet38Client; //# sourceMappingURL=comet38client.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
/**
 * Returns true iff transaction made it successfully into the transaction pool
 */ function broadcastTxSyncSuccess(res) {
    // code must be 0 on success
    return res.code === 0;
}
exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
/**
 * Returns true iff transaction made it successfully into a block
 * (i.e. success in `check_tx` and `deliver_tx` field)
 */ function broadcastTxCommitSuccess(response) {
    // code must be 0 on success
    // deliverTx may be present but empty on failure
    return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
}
exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
/**
 * raw values from https://github.com/tendermint/tendermint/blob/dfa9a9a30a666132425b29454e90a472aa579a48/types/vote.go#L44
 */ var VoteType;
(function(VoteType) {
    VoteType[VoteType["PreVote"] = 1] = "PreVote";
    VoteType[VoteType["PreCommit"] = 2] = "PreCommit";
})(VoteType = exports.VoteType || (exports.VoteType = {})); //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: all exports in this module are publicly available via
// `import { comet38 } from "@cosmjs/tendermint-rpc"`
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
var comet38client_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js [client] (ecmascript)");
Object.defineProperty(exports, "Comet38Client", {
    enumerable: true,
    get: function() {
        return comet38client_1.Comet38Client;
    }
});
var requests_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js [client] (ecmascript)");
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return requests_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return requests_1.SubscriptionEventType;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js [client] (ecmascript)");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return responses_1.VoteType;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
/**
 * RPC methods as documented in https://docs.tendermint.com/master/rpc/
 *
 * Enum raw value must match the spelling in the "shell" example call (snake_case)
 */ var Method;
(function(Method) {
    Method["AbciInfo"] = "abci_info";
    Method["AbciQuery"] = "abci_query";
    Method["Block"] = "block";
    /** Get block headers for minHeight <= height <= maxHeight. */ Method["Blockchain"] = "blockchain";
    Method["BlockResults"] = "block_results";
    Method["BlockSearch"] = "block_search";
    Method["BroadcastTxAsync"] = "broadcast_tx_async";
    Method["BroadcastTxSync"] = "broadcast_tx_sync";
    Method["BroadcastTxCommit"] = "broadcast_tx_commit";
    Method["Commit"] = "commit";
    Method["Genesis"] = "genesis";
    Method["Health"] = "health";
    Method["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
    Method["Status"] = "status";
    Method["Subscribe"] = "subscribe";
    Method["Tx"] = "tx";
    Method["TxSearch"] = "tx_search";
    Method["Validators"] = "validators";
    Method["Unsubscribe"] = "unsubscribe";
})(Method = exports.Method || (exports.Method = {}));
/**
 * Raw values must match the tendermint event name
 *
 * @see https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
 */ var SubscriptionEventType;
(function(SubscriptionEventType) {
    SubscriptionEventType["NewBlock"] = "NewBlock";
    SubscriptionEventType["NewBlockHeader"] = "NewBlockHeader";
    SubscriptionEventType["Tx"] = "Tx";
})(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
function buildQuery(components) {
    const tags = components.tags ? components.tags : [];
    const tagComponents = tags.map((tag)=>`${tag.key}='${tag.value}'`);
    const rawComponents = components.raw ? [
        components.raw
    ] : [];
    return [
        ...tagComponents,
        ...rawComponents
    ].join(" AND ");
}
exports.buildQuery = buildQuery; //# sourceMappingURL=requests.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
/**
 * Returns true iff transaction made it successfully into the transaction pool
 */ function broadcastTxSyncSuccess(res) {
    // code must be 0 on success
    return res.code === 0;
}
exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
/**
 * Returns true iff transaction made it successfully into a block
 * (i.e. success in `check_tx` and `deliver_tx` field)
 */ function broadcastTxCommitSuccess(response) {
    // code must be 0 on success
    // deliverTx may be present but empty on failure
    return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
}
exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
/**
 * raw values from https://github.com/tendermint/tendermint/blob/dfa9a9a30a666132425b29454e90a472aa579a48/types/vote.go#L44
 */ var VoteType;
(function(VoteType) {
    VoteType[VoteType["PreVote"] = 1] = "PreVote";
    VoteType[VoteType["PreCommit"] = 2] = "PreCommit";
})(VoteType = exports.VoteType || (exports.VoteType = {})); //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const inthelpers_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)");
const jsonrpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js [client] (ecmascript)");
const requests = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js [client] (ecmascript)"));
function encodeHeightParam(param) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
    };
}
function encodeBlockchainRequestParams(param) {
    return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
    };
}
function encodeBlockSearchParams(params) {
    return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeAbciQueryParams(params) {
    return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
    };
}
function encodeBroadcastTxParams(params) {
    return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
    };
}
function encodeTxParams(params) {
    return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
    };
}
function encodeTxSearchParams(params) {
    return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeValidatorsParams(params) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
    };
}
class Params {
    static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
    }
    static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
    }
    static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
    }
    static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
    }
    static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeSubscribe(req) {
        const eventTag = {
            key: "tm.event",
            value: req.query.type
        };
        const query = requests.buildQuery({
            tags: [
                eventTag
            ],
            raw: req.query.raw
        });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", {
            query: query
        });
    }
    static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
    }
    // TODO: encode params for query string???
    static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
    }
    static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
    }
}
exports.Params = Params; //# sourceMappingURL=requests.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashBlock = exports.hashTx = void 0;
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/crypto/build/index.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js [client] (ecmascript)");
// hash is sha256
// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260
function hashTx(tx) {
    return (0, crypto_1.sha256)(tx);
}
exports.hashTx = hashTx;
function getSplitPoint(n) {
    if (n < 1) throw new Error("Cannot split an empty tree");
    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
}
function hashLeaf(leaf) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        0
    ]));
    hash.update(leaf);
    return hash.digest();
}
function hashInner(left, right) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        1
    ]));
    hash.update(left);
    hash.update(right);
    return hash.digest();
}
// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot
// Note: the hashes input may not actually be hashes, especially before a recursive call
function hashTree(hashes) {
    switch(hashes.length){
        case 0:
            throw new Error("Cannot hash empty tree");
        case 1:
            return hashLeaf(hashes[0]);
        default:
            {
                const slicePoint = getSplitPoint(hashes.length);
                const left = hashTree(hashes.slice(0, slicePoint));
                const right = hashTree(hashes.slice(slicePoint));
                return hashInner(left, right);
            }
    }
}
function hashBlock(header) {
    if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
    }
    const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
    ];
    return hashTree(encodedFields);
}
exports.hashBlock = hashBlock; //# sourceMappingURL=hasher.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const dates_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/dates.js [client] (ecmascript)");
const inthelpers_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/types.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js [client] (ecmascript)");
const hasher_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js [client] (ecmascript)");
function decodeAbciInfo(data) {
    return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
    };
}
function decodeQueryProof(data) {
    return {
        ops: data.ops.map((op)=>({
                type: op.type,
                key: (0, encoding_1.fromBase64)(op.key),
                data: (0, encoding_1.fromBase64)(op.data)
            }))
    };
}
function decodeAbciQuery(data) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
    };
}
function decodeAttribute(attribute) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(attribute.value ?? ""))
    };
}
function decodeAttributes(attributes) {
    return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
}
function decodeEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
    };
}
exports.decodeEvent = decodeEvent;
function decodeEvents(events) {
    return (0, encodings_1.assertArray)(events).map(decodeEvent);
}
function decodeTxData(data) {
    return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
    };
}
function decodePubkey(data) {
    if ("Sum" in data) {
        // we don't need to check type because we're checking algorithm
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
            algorithm,
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
    } else {
        switch(data.type){
            // go-amino special code
            case "tendermint/PubKeyEd25519":
                return {
                    algorithm: "ed25519",
                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
                };
            case "tendermint/PubKeySecp256k1":
                return {
                    algorithm: "secp256k1",
                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
                };
            default:
                throw new Error(`unknown pubkey type: ${data.type}`);
        }
    }
}
/**
 * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry
 *
 * > Add time_iota_ms to block's consensus parameters (not exposed to the application)
 * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310
 */ function decodeBlockParams(data) {
    return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
    };
}
function decodeEvidenceParams(data) {
    return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
    };
}
function decodeConsensusParams(data) {
    return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
    };
}
function decodeValidatorUpdate(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
    };
}
exports.decodeValidatorUpdate = decodeValidatorUpdate;
function decodeBlockResults(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
    };
}
function decodeBlockId(data) {
    return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
            total: (0, encodings_1.assertNotEmpty)(data.parts.total),
            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
    };
}
function decodeBlockVersion(data) {
    return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
    };
}
function decodeHeader(data) {
    return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
    };
}
function decodeBlockMeta(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
    };
}
function decodeBlockchain(data) {
    return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
    };
}
function decodeBroadcastTxSync(data) {
    return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
    };
}
function decodeBroadcastTxCommit(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
    };
}
function decodeBlockIdFlag(blockIdFlag) {
    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
    return blockIdFlag;
}
function decodeCommitSignature(data) {
    return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : undefined,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined
    };
}
function decodeCommit(data) {
    return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
    };
}
function decodeCommitResponse(data) {
    return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
    };
}
function decodeValidatorGenesis(data) {
    return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
    };
}
exports.decodeValidatorGenesis = decodeValidatorGenesis;
function decodeGenesis(data) {
    return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
    };
}
function decodeValidatorInfo(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined
    };
}
exports.decodeValidatorInfo = decodeValidatorInfo;
function decodeNodeInfo(data) {
    return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertNotEmpty)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
            app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
            block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
            p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
    };
}
function decodeSyncInfo(data) {
    const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : undefined;
    const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : undefined;
    return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : undefined,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : undefined,
        earliestBlockHeight: earliestBlockHeight || undefined,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : undefined,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
    };
}
function decodeStatus(data) {
    return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
    };
}
function decodeTxProof(data) {
    return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
            total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
            index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
    };
}
function decodeTxResponse(data) {
    return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
    };
}
function decodeTxSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
    };
}
function decodeTxEvent(data) {
    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
    return {
        tx: tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
    };
}
function decodeValidators(data) {
    return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
    };
}
function decodeBlock(data) {
    return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
    };
}
function decodeBlockResponse(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
    };
}
function decodeBlockSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
    };
}
function decodeNumUnconfirmedTxs(data) {
    return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
    };
}
class Responses {
    static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeBlock(response) {
        return decodeBlockResponse(response.result);
    }
    static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
    }
    static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
    }
    static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
    }
    static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
    }
    static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
    }
    static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
    }
    static decodeCommit(response) {
        return decodeCommitResponse(response.result);
    }
    static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
    }
    static decodeHealth() {
        return null;
    }
    static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
    }
    static decodeStatus(response) {
        return decodeStatus(response.result);
    }
    static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
    }
    static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
    }
    static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
    }
    static decodeTx(response) {
        return decodeTxResponse(response.result);
    }
    static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
    }
    static decodeValidators(response) {
        return decodeValidators(response.result);
    }
}
exports.Responses = Responses; //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.Params = void 0;
var requests_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js [client] (ecmascript)");
Object.defineProperty(exports, "Params", {
    enumerable: true,
    get: function() {
        return requests_1.Params;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js [client] (ecmascript)");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint34Client = void 0;
const jsonrpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)");
const rpcclients_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js [client] (ecmascript)");
const adaptor_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js [client] (ecmascript)");
const requests = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js [client] (ecmascript)"));
class Tendermint34Client {
    /**
     * Creates a new Tendermint client for the given endpoint.
     *
     * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
     */ static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
            rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
            const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
            rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        // For some very strange reason I don't understand, tests start to fail on some systems
        // (our CI) when skipping the status call before doing other queries. Sleeping a little
        // while did not help. Thus we query the version as a way to say "hi" to the backend,
        // even in cases where we don't use the result.
        const _version = await this.detectVersion(rpcClient);
        return Tendermint34Client.create(rpcClient);
    }
    /**
     * Creates a new Tendermint client given an RPC client.
     */ static async create(rpcClient) {
        return new Tendermint34Client(rpcClient);
    }
    static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
            throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
            throw new Error("Unrecognized version format: must be string");
        }
        return version;
    }
    /**
     * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
     */ constructor(client){
        this.client = client;
    }
    disconnect() {
        this.client.disconnect();
    }
    async abciInfo() {
        const query = {
            method: requests.Method.AbciInfo
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
    }
    async abciQuery(params) {
        const query = {
            params: params,
            method: requests.Method.AbciQuery
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
    }
    async block(height) {
        const query = {
            method: requests.Method.Block,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
    }
    async blockResults(height) {
        const query = {
            method: requests.Method.BlockResults,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
    }
    /**
     * Search for events that are in a block.
     *
     * NOTE
     * This method will error on any node that is running a Tendermint version lower than 0.34.9.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
     */ async blockSearch(params) {
        const query = {
            params: params,
            method: requests.Method.BlockSearch
        };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
            ...resp,
            // make sure we sort by height, as tendermint may be sorting by string value of the height
            blocks: [
                ...resp.blocks
            ].sort((a, b)=>a.block.header.height - b.block.header.height)
        };
    }
    // this should paginate through all blockSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    //
    // NOTE
    // This method will error on any node that is running a Tendermint version lower than 0.34.9.
    async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while(!done){
            const resp = await this.blockSearch({
                ...params,
                page: page
            });
            blocks.push(...resp.blocks);
            if (blocks.length < resp.totalCount) {
                page++;
            } else {
                done = true;
            }
        }
        // make sure we sort by height, as tendermint may be sorting by string value of the height
        // and the earlier items may be in a higher page than the later items
        blocks.sort((a, b)=>a.block.header.height - b.block.header.height);
        return {
            totalCount: blocks.length,
            blocks: blocks
        };
    }
    /**
     * Queries block headers filtered by minHeight <= height <= maxHeight.
     *
     * @param minHeight The minimum height to be included in the result. Defaults to 0.
     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
     */ async blockchain(minHeight, maxHeight) {
        const query = {
            method: requests.Method.Blockchain,
            params: {
                minHeight: minHeight,
                maxHeight: maxHeight
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
    }
    /**
     * Broadcast transaction to mempool and wait for response
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */ async broadcastTxSync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxSync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
    }
    /**
     * Broadcast transaction to mempool and do not wait for result
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */ async broadcastTxAsync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxAsync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
    }
    /**
     * Broadcast transaction to mempool and wait for block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
     */ async broadcastTxCommit(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxCommit
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
    }
    async commit(height) {
        const query = {
            method: requests.Method.Commit,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
    }
    async genesis() {
        const query = {
            method: requests.Method.Genesis
        };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
    }
    async health() {
        const query = {
            method: requests.Method.Health
        };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
    }
    async numUnconfirmedTxs() {
        const query = {
            method: requests.Method.NumUnconfirmedTxs
        };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
    }
    async status() {
        const query = {
            method: requests.Method.Status
        };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
    }
    subscribeNewBlock() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlock
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
    }
    subscribeNewBlockHeader() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlockHeader
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
    }
    subscribeTx(query) {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.Tx,
                raw: query
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
    }
    /**
     * Get a single transaction by hash
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx
     */ async tx(params) {
        const query = {
            params: params,
            method: requests.Method.Tx
        };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
    }
    /**
     * Search for transactions that are in a block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
     */ async txSearch(params) {
        const query = {
            params: params,
            method: requests.Method.TxSearch
        };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
    }
    // this should paginate through all txSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while(!done){
            const resp = await this.txSearch({
                ...params,
                page: page
            });
            txs.push(...resp.txs);
            if (txs.length < resp.totalCount) {
                page++;
            } else {
                done = true;
            }
        }
        return {
            totalCount: txs.length,
            txs: txs
        };
    }
    async validators(params) {
        const query = {
            method: requests.Method.Validators,
            params: params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
    }
    async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while(!done){
            const response = await this.validators({
                per_page: 50,
                height: blockHeight,
                page: page
            });
            validators.push(...response.validators);
            blockHeight = blockHeight || response.blockHeight;
            if (validators.length < response.total) {
                page++;
            } else {
                done = true;
            }
        }
        return {
            // NOTE: Default value is for type safety but this should always be set
            blockHeight: blockHeight ?? 0,
            count: validators.length,
            total: validators.length,
            validators: validators
        };
    }
    // doCall is a helper to handle the encode/call/decode logic
    async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
    }
    subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
            throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event)=>{
            return decode(event);
        });
    }
}
exports.Tendermint34Client = Tendermint34Client; //# sourceMappingURL=tendermint34client.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: all exports in this module are publicly available via
// `import { tendermint34 } from "@cosmjs/tendermint-rpc"`
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
var requests_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js [client] (ecmascript)");
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return requests_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return requests_1.SubscriptionEventType;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js [client] (ecmascript)");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return responses_1.VoteType;
    }
});
var tendermint34client_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js [client] (ecmascript)");
Object.defineProperty(exports, "Tendermint34Client", {
    enumerable: true,
    get: function() {
        return tendermint34client_1.Tendermint34Client;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
/**
 * RPC methods as documented in https://docs.tendermint.com/master/rpc/
 *
 * Enum raw value must match the spelling in the "shell" example call (snake_case)
 */ var Method;
(function(Method) {
    Method["AbciInfo"] = "abci_info";
    Method["AbciQuery"] = "abci_query";
    Method["Block"] = "block";
    /** Get block headers for minHeight <= height <= maxHeight. */ Method["Blockchain"] = "blockchain";
    Method["BlockResults"] = "block_results";
    Method["BlockSearch"] = "block_search";
    Method["BroadcastTxAsync"] = "broadcast_tx_async";
    Method["BroadcastTxSync"] = "broadcast_tx_sync";
    Method["BroadcastTxCommit"] = "broadcast_tx_commit";
    Method["Commit"] = "commit";
    Method["Genesis"] = "genesis";
    Method["Health"] = "health";
    Method["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
    Method["Status"] = "status";
    Method["Subscribe"] = "subscribe";
    Method["Tx"] = "tx";
    Method["TxSearch"] = "tx_search";
    Method["Validators"] = "validators";
    Method["Unsubscribe"] = "unsubscribe";
})(Method = exports.Method || (exports.Method = {}));
/**
 * Raw values must match the tendermint event name
 *
 * @see https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
 */ var SubscriptionEventType;
(function(SubscriptionEventType) {
    SubscriptionEventType["NewBlock"] = "NewBlock";
    SubscriptionEventType["NewBlockHeader"] = "NewBlockHeader";
    SubscriptionEventType["Tx"] = "Tx";
})(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
function buildQuery(components) {
    const tags = components.tags ? components.tags : [];
    const tagComponents = tags.map((tag)=>`${tag.key}='${tag.value}'`);
    const rawComponents = components.raw ? [
        components.raw
    ] : [];
    return [
        ...tagComponents,
        ...rawComponents
    ].join(" AND ");
}
exports.buildQuery = buildQuery; //# sourceMappingURL=requests.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
/**
 * Returns true iff transaction made it successfully into the transaction pool
 */ function broadcastTxSyncSuccess(res) {
    // code must be 0 on success
    return res.code === 0;
}
exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
/**
 * Returns true iff transaction made it successfully into a block
 * (i.e. success in `check_tx` and `deliver_tx` field)
 */ function broadcastTxCommitSuccess(response) {
    // code must be 0 on success
    // deliverTx may be present but empty on failure
    return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
}
exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
/**
 * raw values from https://github.com/tendermint/tendermint/blob/dfa9a9a30a666132425b29454e90a472aa579a48/types/vote.go#L44
 */ var VoteType;
(function(VoteType) {
    VoteType[VoteType["PreVote"] = 1] = "PreVote";
    VoteType[VoteType["PreCommit"] = 2] = "PreCommit";
})(VoteType = exports.VoteType || (exports.VoteType = {})); //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeUvarint = exports.encodeString = exports.dictionaryToStringMap = exports.may = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
/**
 * A runtime checker that ensures a given value is set (i.e. not undefined or null)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 */ function assertSet(value) {
    if (value === undefined) {
        throw new Error("Value must not be undefined");
    }
    if (value === null) {
        throw new Error("Value must not be null");
    }
    return value;
}
exports.assertSet = assertSet;
/**
 * A runtime checker that ensures a given value is a boolean
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertBoolean(value) {
    assertSet(value);
    if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
    }
    return value;
}
exports.assertBoolean = assertBoolean;
/**
 * A runtime checker that ensures a given value is a string.
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertString(value) {
    assertSet(value);
    if (typeof value !== "string") {
        throw new Error("Value must be a string");
    }
    return value;
}
exports.assertString = assertString;
/**
 * A runtime checker that ensures a given value is a number
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertNumber(value) {
    assertSet(value);
    if (typeof value !== "number") {
        throw new Error("Value must be a number");
    }
    return value;
}
exports.assertNumber = assertNumber;
/**
 * A runtime checker that ensures a given value is an array
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertArray(value) {
    assertSet(value);
    if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
    }
    return value;
}
exports.assertArray = assertArray;
/**
 * A runtime checker that ensures a given value is an object in the sense of JSON
 * (an unordered collection of key–value pairs where the keys are strings)
 *
 * This is used when you want to verify that data at runtime matches the expected type.
 * This implies assertSet.
 */ function assertObject(value) {
    assertSet(value);
    if (typeof value !== "object") {
        throw new Error("Value must be an object");
    }
    // Exclude special kind of objects like Array, Date or Uint8Array
    // Object.prototype.toString() returns a specified value:
    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring
    if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
    }
    return value;
}
exports.assertObject = assertObject;
/**
 * Throws an error if value matches the empty value for the
 * given type (array/string of length 0, number of value 0, ...)
 *
 * Otherwise returns the value.
 *
 * This implies assertSet
 */ function assertNotEmpty(value) {
    assertSet(value);
    if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
    } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
    }
    return value;
}
exports.assertNotEmpty = assertNotEmpty;
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
exports.may = may;
function dictionaryToStringMap(obj) {
    const out = new Map();
    for (const key of Object.keys(obj)){
        const value = obj[key];
        if (typeof value !== "string") {
            throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
    }
    return out;
}
exports.dictionaryToStringMap = dictionaryToStringMap;
// Encodings needed for hashing block headers
// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195
function encodeString(s) {
    const utf8 = (0, encoding_1.toUtf8)(s);
    return Uint8Array.from([
        utf8.length,
        ...utf8
    ]);
}
exports.encodeString = encodeString;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87
function encodeUvarint(n) {
    return n >= 0x80 ? Uint8Array.from([
        n & 0xff | 0x80,
        ...encodeUvarint(n >> 7)
    ]) : Uint8Array.from([
        n & 0xff
    ]);
}
exports.encodeUvarint = encodeUvarint;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178
function encodeTime(time) {
    const milliseconds = time.getTime();
    const seconds = Math.floor(milliseconds / 1000);
    const secondsArray = seconds ? [
        0x08,
        ...encodeUvarint(seconds)
    ] : new Uint8Array();
    const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;
    const nanosecondsArray = nanoseconds ? [
        0x10,
        ...encodeUvarint(nanoseconds)
    ] : new Uint8Array();
    return Uint8Array.from([
        ...secondsArray,
        ...nanosecondsArray
    ]);
}
exports.encodeTime = encodeTime;
// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187
function encodeBytes(bytes) {
    // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet
    if (bytes.length >= 0x80) throw new Error("Not implemented for byte arrays of length 128 or more");
    return bytes.length ? Uint8Array.from([
        bytes.length,
        ...bytes
    ]) : new Uint8Array();
}
exports.encodeBytes = encodeBytes;
function encodeVersion(version) {
    const blockArray = version.block ? Uint8Array.from([
        0x08,
        ...encodeUvarint(version.block)
    ]) : new Uint8Array();
    const appArray = version.app ? Uint8Array.from([
        0x10,
        ...encodeUvarint(version.app)
    ]) : new Uint8Array();
    return Uint8Array.from([
        ...blockArray,
        ...appArray
    ]);
}
exports.encodeVersion = encodeVersion;
function encodeBlockId(blockId) {
    return Uint8Array.from([
        0x0a,
        blockId.hash.length,
        ...blockId.hash,
        0x12,
        blockId.parts.hash.length + 4,
        0x08,
        blockId.parts.total,
        0x12,
        blockId.parts.hash.length,
        ...blockId.parts.hash
    ]);
}
exports.encodeBlockId = encodeBlockId; //# sourceMappingURL=encodings.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Params = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const inthelpers_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)");
const jsonrpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js [client] (ecmascript)");
const requests = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js [client] (ecmascript)"));
function encodeHeightParam(param) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
    };
}
function encodeBlockchainRequestParams(param) {
    return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
    };
}
function encodeBlockSearchParams(params) {
    return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeAbciQueryParams(params) {
    return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
    };
}
function encodeBroadcastTxParams(params) {
    return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
    };
}
function encodeTxParams(params) {
    return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
    };
}
function encodeTxSearchParams(params) {
    return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
    };
}
function encodeValidatorsParams(params) {
    return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
    };
}
class Params {
    static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
    }
    static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
    }
    static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
    }
    static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
    }
    static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
    }
    static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
    }
    static encodeSubscribe(req) {
        const eventTag = {
            key: "tm.event",
            value: req.query.type
        };
        const query = requests.buildQuery({
            tags: [
                eventTag
            ],
            raw: req.query.raw
        });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", {
            query: query
        });
    }
    static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
    }
    // TODO: encode params for query string???
    static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
    }
    static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
    }
}
exports.Params = Params; //# sourceMappingURL=requests.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashBlock = exports.hashTx = void 0;
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/crypto/build/index.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js [client] (ecmascript)");
// hash is sha256
// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260
function hashTx(tx) {
    return (0, crypto_1.sha256)(tx);
}
exports.hashTx = hashTx;
function getSplitPoint(n) {
    if (n < 1) throw new Error("Cannot split an empty tree");
    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
}
function hashLeaf(leaf) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        0
    ]));
    hash.update(leaf);
    return hash.digest();
}
function hashInner(left, right) {
    const hash = new crypto_1.Sha256(Uint8Array.from([
        1
    ]));
    hash.update(left);
    hash.update(right);
    return hash.digest();
}
// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot
// Note: the hashes input may not actually be hashes, especially before a recursive call
function hashTree(hashes) {
    switch(hashes.length){
        case 0:
            throw new Error("Cannot hash empty tree");
        case 1:
            return hashLeaf(hashes[0]);
        default:
            {
                const slicePoint = getSplitPoint(hashes.length);
                const left = hashTree(hashes.slice(0, slicePoint));
                const right = hashTree(hashes.slice(slicePoint));
                return hashInner(left, right);
            }
    }
}
function hashBlock(header) {
    if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
    }
    const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
    ];
    return hashTree(encodedFields);
}
exports.hashBlock = hashBlock; //# sourceMappingURL=hasher.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const encoding_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/encoding/build/index.js [client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/utils/build/index.js [client] (ecmascript)");
const dates_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/dates.js [client] (ecmascript)");
const inthelpers_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js [client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/types.js [client] (ecmascript)");
const encodings_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js [client] (ecmascript)");
const hasher_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js [client] (ecmascript)");
function decodeAbciInfo(data) {
    return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
    };
}
function decodeQueryProof(data) {
    return {
        ops: data.ops.map((op)=>({
                type: op.type,
                key: (0, encoding_1.fromBase64)(op.key),
                data: (0, encoding_1.fromBase64)(op.data)
            }))
    };
}
function decodeAbciQuery(data) {
    return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.assertString)(data.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.code),
        codespace: (0, encodings_1.assertString)(data.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data.index),
        log: data.log,
        info: (0, encodings_1.assertString)(data.info ?? "")
    };
}
function decodeEventAttribute(attribute) {
    return {
        key: (0, encodings_1.assertNotEmpty)(attribute.key),
        value: attribute.value ?? ""
    };
}
function decodeAttributes(attributes) {
    return (0, encodings_1.assertArray)(attributes).map(decodeEventAttribute);
}
function decodeEvent(event) {
    return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
    };
}
exports.decodeEvent = decodeEvent;
function decodeEvents(events) {
    return (0, encodings_1.assertArray)(events).map(decodeEvent);
}
function decodeTxData(data) {
    return {
        code: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.code ?? 0)),
        codespace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data.gas_used ?? "0")
    };
}
function decodePubkey(data) {
    if ("Sum" in data) {
        // we don't need to check type because we're checking algorithm
        const [[algorithm, value]] = Object.entries(data.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
            algorithm,
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))
        };
    } else {
        switch(data.type){
            // go-amino special code
            case "tendermint/PubKeyEd25519":
                return {
                    algorithm: "ed25519",
                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
                };
            case "tendermint/PubKeySecp256k1":
                return {
                    algorithm: "secp256k1",
                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
                };
            default:
                throw new Error(`unknown pubkey type: ${data.type}`);
        }
    }
}
/**
 * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry
 *
 * > Add time_iota_ms to block's consensus parameters (not exposed to the application)
 * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310
 */ function decodeBlockParams(data) {
    return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_gas))
    };
}
function decodeEvidenceParams(data) {
    return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.max_age_duration))
    };
}
function decodeConsensusParams(data) {
    return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
    };
}
function decodeValidatorUpdate(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data.power ?? "0")
    };
}
exports.decodeValidatorUpdate = decodeValidatorUpdate;
function decodeBlockResults(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
    };
}
function decodeBlockId(data) {
    return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
            total: (0, encodings_1.assertNotEmpty)(data.parts.total),
            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
    };
}
function decodeBlockVersion(data) {
    return {
        block: (0, inthelpers_1.apiToSmallInt)(data.block),
        app: (0, inthelpers_1.apiToSmallInt)(data.app ?? 0)
    };
}
function decodeHeader(data) {
    return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
    };
}
function decodeBlockMeta(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.num_txs))
    };
}
function decodeBlockchain(data) {
    return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
    };
}
function decodeBroadcastTxSync(data) {
    return {
        ...decodeTxData(data),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))
    };
}
function decodeBroadcastTxCommit(data) {
    return {
        height: (0, inthelpers_1.apiToSmallInt)(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
    };
}
function decodeBlockIdFlag(blockIdFlag) {
    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
    return blockIdFlag;
}
function decodeCommitSignature(data) {
    return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,
        timestamp: data.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data.timestamp) : undefined,
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined
    };
}
function decodeCommit(data) {
    return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
    };
}
function decodeCommitResponse(data) {
    return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
    };
}
function decodeValidatorGenesis(data) {
    return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.power))
    };
}
exports.decodeValidatorGenesis = decodeValidatorGenesis;
function decodeGenesis(data) {
    return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
    };
}
function decodeValidatorInfo(data) {
    return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: data.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data.proposer_priority) : undefined
    };
}
exports.decodeValidatorInfo = decodeValidatorInfo;
function decodeNodeInfo(data) {
    return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertString)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
            app: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
            block: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
            p2p: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
    };
}
function decodeSyncInfo(data) {
    const earliestBlockHeight = data.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data.earliest_block_height) : undefined;
    const earliestBlockTime = data.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data.earliest_block_time) : undefined;
    return {
        earliestAppHash: data.earliest_app_hash ? (0, encoding_1.fromHex)(data.earliest_app_hash) : undefined,
        earliestBlockHash: data.earliest_block_hash ? (0, encoding_1.fromHex)(data.earliest_block_hash) : undefined,
        earliestBlockHeight: earliestBlockHeight || undefined,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : undefined,
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
    };
}
function decodeStatus(data) {
    return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
    };
}
function decodeTxProof(data) {
    return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
            total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.total)),
            index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.proof.index)),
            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
    };
}
function decodeTxResponse(data) {
    return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
    };
}
function decodeTxSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
    };
}
function decodeTxEvent(data) {
    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
    return {
        tx: tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.height))
    };
}
function decodeValidators(data) {
    return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total))
    };
}
function decodeBlock(data) {
    return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data.evidence?.evidence ?? []
    };
}
function decodeBlockResponse(data) {
    return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
    };
}
function decodeBlockSearch(data) {
    return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
    };
}
function decodeNumUnconfirmedTxs(data) {
    return {
        total: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, encodings_1.assertNotEmpty)(data.total_bytes))
    };
}
class Responses {
    static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
    }
    static decodeBlock(response) {
        return decodeBlockResponse(response.result);
    }
    static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
    }
    static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
    }
    static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
    }
    static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
    }
    static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
    }
    static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
    }
    static decodeCommit(response) {
        return decodeCommitResponse(response.result);
    }
    static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
    }
    static decodeHealth() {
        return null;
    }
    static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
    }
    static decodeStatus(response) {
        return decodeStatus(response.result);
    }
    static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
    }
    static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
    }
    static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
    }
    static decodeTx(response) {
        return decodeTxResponse(response.result);
    }
    static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
    }
    static decodeValidators(response) {
        return decodeValidators(response.result);
    }
}
exports.Responses = Responses; //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Responses = exports.Params = void 0;
var requests_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js [client] (ecmascript)");
Object.defineProperty(exports, "Params", {
    enumerable: true,
    get: function() {
        return requests_1.Params;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js [client] (ecmascript)");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint37Client = void 0;
const jsonrpc_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js [client] (ecmascript)");
const rpcclients_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js [client] (ecmascript)");
const adaptor_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js [client] (ecmascript)");
const requests = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js [client] (ecmascript)"));
class Tendermint37Client {
    /**
     * Creates a new Tendermint client for the given endpoint.
     *
     * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
     */ static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
            rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
            const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
            rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        // For some very strange reason I don't understand, tests start to fail on some systems
        // (our CI) when skipping the status call before doing other queries. Sleeping a little
        // while did not help. Thus we query the version as a way to say "hi" to the backend,
        // even in cases where we don't use the result.
        const _version = await this.detectVersion(rpcClient);
        return Tendermint37Client.create(rpcClient);
    }
    /**
     * Creates a new Tendermint client given an RPC client.
     */ static async create(rpcClient) {
        return new Tendermint37Client(rpcClient);
    }
    static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
            throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
            throw new Error("Unrecognized version format: must be string");
        }
        return version;
    }
    /**
     * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
     */ constructor(client){
        this.client = client;
    }
    disconnect() {
        this.client.disconnect();
    }
    async abciInfo() {
        const query = {
            method: requests.Method.AbciInfo
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
    }
    async abciQuery(params) {
        const query = {
            params: params,
            method: requests.Method.AbciQuery
        };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
    }
    async block(height) {
        const query = {
            method: requests.Method.Block,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
    }
    async blockResults(height) {
        const query = {
            method: requests.Method.BlockResults,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
    }
    /**
     * Search for events that are in a block.
     *
     * NOTE
     * This method will error on any node that is running a Tendermint version lower than 0.34.9.
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
     */ async blockSearch(params) {
        const query = {
            params: params,
            method: requests.Method.BlockSearch
        };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
            ...resp,
            // make sure we sort by height, as tendermint may be sorting by string value of the height
            blocks: [
                ...resp.blocks
            ].sort((a, b)=>a.block.header.height - b.block.header.height)
        };
    }
    // this should paginate through all blockSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    //
    // NOTE
    // This method will error on any node that is running a Tendermint version lower than 0.34.9.
    async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while(!done){
            const resp = await this.blockSearch({
                ...params,
                page: page
            });
            blocks.push(...resp.blocks);
            if (blocks.length < resp.totalCount) {
                page++;
            } else {
                done = true;
            }
        }
        // make sure we sort by height, as tendermint may be sorting by string value of the height
        // and the earlier items may be in a higher page than the later items
        blocks.sort((a, b)=>a.block.header.height - b.block.header.height);
        return {
            totalCount: blocks.length,
            blocks: blocks
        };
    }
    /**
     * Queries block headers filtered by minHeight <= height <= maxHeight.
     *
     * @param minHeight The minimum height to be included in the result. Defaults to 0.
     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
     */ async blockchain(minHeight, maxHeight) {
        const query = {
            method: requests.Method.Blockchain,
            params: {
                minHeight: minHeight,
                maxHeight: maxHeight
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
    }
    /**
     * Broadcast transaction to mempool and wait for response
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
     */ async broadcastTxSync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxSync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
    }
    /**
     * Broadcast transaction to mempool and do not wait for result
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
     */ async broadcastTxAsync(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxAsync
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
    }
    /**
     * Broadcast transaction to mempool and wait for block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
     */ async broadcastTxCommit(params) {
        const query = {
            params: params,
            method: requests.Method.BroadcastTxCommit
        };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
    }
    async commit(height) {
        const query = {
            method: requests.Method.Commit,
            params: {
                height: height
            }
        };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
    }
    async genesis() {
        const query = {
            method: requests.Method.Genesis
        };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
    }
    async health() {
        const query = {
            method: requests.Method.Health
        };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
    }
    async numUnconfirmedTxs() {
        const query = {
            method: requests.Method.NumUnconfirmedTxs
        };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
    }
    async status() {
        const query = {
            method: requests.Method.Status
        };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
    }
    subscribeNewBlock() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlock
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
    }
    subscribeNewBlockHeader() {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.NewBlockHeader
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
    }
    subscribeTx(query) {
        const request = {
            method: requests.Method.Subscribe,
            query: {
                type: requests.SubscriptionEventType.Tx,
                raw: query
            }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
    }
    /**
     * Get a single transaction by hash
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx
     */ async tx(params) {
        const query = {
            params: params,
            method: requests.Method.Tx
        };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
    }
    /**
     * Search for transactions that are in a block
     *
     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
     */ async txSearch(params) {
        const query = {
            params: params,
            method: requests.Method.TxSearch
        };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
    }
    // this should paginate through all txSearch options to ensure it returns all results.
    // starts with page 1 or whatever was provided (eg. to start on page 7)
    async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while(!done){
            const resp = await this.txSearch({
                ...params,
                page: page
            });
            txs.push(...resp.txs);
            if (txs.length < resp.totalCount) {
                page++;
            } else {
                done = true;
            }
        }
        return {
            totalCount: txs.length,
            txs: txs
        };
    }
    async validators(params) {
        const query = {
            method: requests.Method.Validators,
            params: params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
    }
    async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while(!done){
            const response = await this.validators({
                per_page: 50,
                height: blockHeight,
                page: page
            });
            validators.push(...response.validators);
            blockHeight = blockHeight || response.blockHeight;
            if (validators.length < response.total) {
                page++;
            } else {
                done = true;
            }
        }
        return {
            // NOTE: Default value is for type safety but this should always be set
            blockHeight: blockHeight ?? 0,
            count: validators.length,
            total: validators.length,
            validators: validators
        };
    }
    // doCall is a helper to handle the encode/call/decode logic
    async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
    }
    subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
            throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event)=>{
            return decode(event);
        });
    }
}
exports.Tendermint37Client = Tendermint37Client; //# sourceMappingURL=tendermint37client.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: all exports in this module are publicly available via
// `import { tendermint37 } from "@cosmjs/tendermint-rpc"`
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
var requests_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js [client] (ecmascript)");
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return requests_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return requests_1.SubscriptionEventType;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js [client] (ecmascript)");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return responses_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return responses_1.VoteType;
    }
});
var tendermint37client_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js [client] (ecmascript)");
Object.defineProperty(exports, "Tendermint37Client", {
    enumerable: true,
    get: function() {
        return tendermint37client_1.Tendermint37Client;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.connectComet = exports.isComet38Client = exports.isTendermint37Client = exports.isTendermint34Client = void 0;
const comet38_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js [client] (ecmascript)");
const tendermint34_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js [client] (ecmascript)");
const tendermint37_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js [client] (ecmascript)");
function isTendermint34Client(client) {
    return client instanceof tendermint34_1.Tendermint34Client;
}
exports.isTendermint34Client = isTendermint34Client;
function isTendermint37Client(client) {
    return client instanceof tendermint37_1.Tendermint37Client;
}
exports.isTendermint37Client = isTendermint37Client;
function isComet38Client(client) {
    return client instanceof comet38_1.Comet38Client;
}
exports.isComet38Client = isComet38Client;
/**
 * Auto-detects the version of the backend and uses a suitable client.
 */ async function connectComet(endpoint) {
    // Tendermint/CometBFT 0.34/0.37/0.38 auto-detection. Starting with 0.37 we seem to get reliable versions again 🎉
    // Using 0.34 as the fallback.
    let out;
    const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
    const version = (await tm37Client.status()).nodeInfo.version;
    if (version.startsWith("0.37.")) {
        out = tm37Client;
    } else if (version.startsWith("0.38.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
    } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
    }
    return out;
}
exports.connectComet = connectComet; //# sourceMappingURL=tendermintclient.js.map
}),
"[project]/node_modules/@cosmjs/tendermint-rpc/build/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
var addresses_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/addresses.js [client] (ecmascript)");
Object.defineProperty(exports, "pubkeyToAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.pubkeyToAddress;
    }
});
Object.defineProperty(exports, "pubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.pubkeyToRawAddress;
    }
});
Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.rawEd25519PubkeyToRawAddress;
    }
});
Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", {
    enumerable: true,
    get: function() {
        return addresses_1.rawSecp256k1PubkeyToRawAddress;
    }
});
var dates_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/dates.js [client] (ecmascript)");
Object.defineProperty(exports, "DateTime", {
    enumerable: true,
    get: function() {
        return dates_1.DateTime;
    }
});
Object.defineProperty(exports, "fromRfc3339WithNanoseconds", {
    enumerable: true,
    get: function() {
        return dates_1.fromRfc3339WithNanoseconds;
    }
});
Object.defineProperty(exports, "fromSeconds", {
    enumerable: true,
    get: function() {
        return dates_1.fromSeconds;
    }
});
Object.defineProperty(exports, "toRfc3339WithNanoseconds", {
    enumerable: true,
    get: function() {
        return dates_1.toRfc3339WithNanoseconds;
    }
});
Object.defineProperty(exports, "toSeconds", {
    enumerable: true,
    get: function() {
        return dates_1.toSeconds;
    }
});
// The public Tendermint34Client.create constructor allows manually choosing an RpcClient.
// This is currently the only way to switch to the HttpBatchClient (which may become default at some point).
// Due to this API, we make RPC client implementations public.
exports.comet38 = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js [client] (ecmascript)"));
var comet38_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js [client] (ecmascript)");
Object.defineProperty(exports, "Comet38Client", {
    enumerable: true,
    get: function() {
        return comet38_1.Comet38Client;
    }
});
var rpcclients_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js [client] (ecmascript)");
Object.defineProperty(exports, "HttpBatchClient", {
    enumerable: true,
    get: function() {
        return rpcclients_1.HttpBatchClient;
    }
});
Object.defineProperty(exports, "HttpClient", {
    enumerable: true,
    get: function() {
        return rpcclients_1.HttpClient;
    }
});
Object.defineProperty(exports, "WebsocketClient", {
    enumerable: true,
    get: function() {
        return rpcclients_1.WebsocketClient;
    }
});
var tendermint34_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js [client] (ecmascript)");
Object.defineProperty(exports, "broadcastTxCommitSuccess", {
    enumerable: true,
    get: function() {
        return tendermint34_1.broadcastTxCommitSuccess;
    }
});
Object.defineProperty(exports, "broadcastTxSyncSuccess", {
    enumerable: true,
    get: function() {
        return tendermint34_1.broadcastTxSyncSuccess;
    }
});
Object.defineProperty(exports, "Method", {
    enumerable: true,
    get: function() {
        return tendermint34_1.Method;
    }
});
Object.defineProperty(exports, "SubscriptionEventType", {
    enumerable: true,
    get: function() {
        return tendermint34_1.SubscriptionEventType;
    }
});
Object.defineProperty(exports, "VoteType", {
    enumerable: true,
    get: function() {
        return tendermint34_1.VoteType;
    }
});
exports.tendermint34 = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js [client] (ecmascript)"));
var tendermint34_2 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js [client] (ecmascript)");
Object.defineProperty(exports, "Tendermint34Client", {
    enumerable: true,
    get: function() {
        return tendermint34_2.Tendermint34Client;
    }
});
exports.tendermint37 = __importStar(__turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js [client] (ecmascript)"));
var tendermint37_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js [client] (ecmascript)");
Object.defineProperty(exports, "Tendermint37Client", {
    enumerable: true,
    get: function() {
        return tendermint37_1.Tendermint37Client;
    }
});
var tendermintclient_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js [client] (ecmascript)");
Object.defineProperty(exports, "connectComet", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.connectComet;
    }
});
Object.defineProperty(exports, "isComet38Client", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.isComet38Client;
    }
});
Object.defineProperty(exports, "isTendermint34Client", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.isTendermint34Client;
    }
});
Object.defineProperty(exports, "isTendermint37Client", {
    enumerable: true,
    get: function() {
        return tendermintclient_1.isTendermint37Client;
    }
});
var types_1 = __turbopack_context__.r("[project]/node_modules/@cosmjs/tendermint-rpc/build/types.js [client] (ecmascript)");
Object.defineProperty(exports, "BlockIdFlag", {
    enumerable: true,
    get: function() {
        return types_1.BlockIdFlag;
    }
}); //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40cosmjs_tendermint-rpc_build_d72a27b7._.js.map